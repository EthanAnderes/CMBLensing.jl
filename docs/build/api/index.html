<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · CMBLensing.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/cmblensing.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CMBLensing.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">CMBLensing.jl</a></li><li><a class="toctext" href="../lense_a_map/">Lensing a flat map</a></li><li><a class="toctext" href="../joint_MAP_example/">Joint maximum a posterior estimate</a></li><li class="current"><a class="toctext" href>API</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API</a></li></ul><a class="edit-page" href="https://github.com/marius311/CMBLensing.jl/blob/master/docs/src-staging/api.md#"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-1" href="#API-1">API</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.Cℓ_to_cov-Union{Tuple{P}, Tuple{T}, Tuple{Type{T},Type{P},Type{S0},InterpolatedCℓs}} where P where T" href="#CMBLensing.Cℓ_to_cov-Union{Tuple{P}, Tuple{T}, Tuple{Type{T},Type{P},Type{S0},InterpolatedCℓs}} where P where T"><code>CMBLensing.Cℓ_to_cov</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Convert power spectrum Cℓ to a flat sky diagonal covariance </p></div></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/flat_s0.jl#L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.MAP_joint-Tuple{Any}" href="#CMBLensing.MAP_joint-Tuple{Any}"><code>CMBLensing.MAP_joint</code></a> — <span class="docstring-category">Method</span>.</div><div><pre class="language-none"><code class="language-none">MAP_joint(ds::DataSet; L=LenseFlow, Nϕ=nothing, quasi_sample=nothing, nsteps=10, Ncg=500, cgtol=1e-1, αtol=1e-5, αmax=0.5, progress=false)</code></pre><p>Compute the maximum a posteri estimate (MAP) from the joint posterior (can also do a quasi-sample). </p><p>The <code>ds</code> argument stores the data and other relevant objects for the dataset being considered. <code>L</code> gives which type of lensing operator to use. </p><p><code>ϕstart</code> can be used to specify the starting point of the minimizer, but this is not necessary and otherwise it will start at ϕ=0. </p><p><code>Nϕ</code> can optionally specify an estimate of the ϕ effective noise, and if provided is used to estimate a Hessian which is used in the ϕ quasi-Newton-Rhapson step. <code>Nϕ=:qe</code> automatically uses the quadratic estimator noise. </p><p>This function can also be used to draw quasi-samples, wherein for the f step, we draw a sample from  P(f|ϕ) instead of maximizing it (ie instead of computing Wiener filter). <code>quasi_sample</code> can be set to an integer seed, in which case each time in the <code>f</code> step we draw a same-seeded sample. If <code>quasi_sample</code> is instead just <code>true</code>, then each iteration in the algorithm draws a different sample so the solution bounces around rather than asymptoting to a maximum. </p><p>The following arguments control the maximiation procedure, and can generally be left at their defaults:</p><ul><li><code>nsteps</code> - The number of iteration steps to do (each iteration updates f then updates ϕ)</li><li><code>Ncg</code> - Maximum number of conjugate gradient steps during the f update</li><li><code>cgtol</code> - Conjugrate gradient tolerance (will stop at cgtol or Ncg, whichever is first)</li><li><code>αtol</code> - Tolerance for the linesearch in the ϕ quasi-Newton-Rhapson step, <code>x′ = x - α*H⁻¹*g</code></li><li><code>αmax</code> - Maximum value for α in the linesearch</li><li><code>progress</code> - Whether to print out conjugate gradient progress.</li></ul><p>Returns a tuple <code>(f, ϕ, tr)</code> where <code>f</code> is the best-fit (or quasi-sample) field, <code>ϕ</code> is the lensing potential, and <code>tr</code> contains info about the run. </p></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/likelihood.jl#L318">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.MAP_marg-Tuple{Any}" href="#CMBLensing.MAP_marg-Tuple{Any}"><code>CMBLensing.MAP_marg</code></a> — <span class="docstring-category">Method</span>.</div><div><pre class="language-none"><code class="language-none">MAP_marg( ds; kwargs...)</code></pre><p>Compute the maximum a posteri estimate (MAP) of the marginl posterior.</p></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/likelihood.jl#L444">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.animate-Tuple{Union{AbstractArray{#s53,1}, AbstractArray{#s53,2}} where #s53&lt;:Field}" href="#CMBLensing.animate-Tuple{Union{AbstractArray{#s53,1}, AbstractArray{#s53,2}} where #s53&lt;:Field}"><code>CMBLensing.animate</code></a> — <span class="docstring-category">Method</span>.</div><div><pre class="language-none"><code class="language-none">animate(fields::Vector{\&lt;:Vector{\&lt;:Field}}; interval=50, motionblur=true, kwargs...)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/plotting.jl#L99">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.bcggd-Union{Tuple{LJ}, Tuple{L}, Tuple{Any,Any,Any,Type{L}}, Tuple{Any,Any,Any,Type{L},Type{LJ}}} where LJ&lt;:LenseOp where L&lt;:LenseOp" href="#CMBLensing.bcggd-Union{Tuple{LJ}, Tuple{L}, Tuple{Any,Any,Any,Type{L}}, Tuple{Any,Any,Any,Type{L},Type{LJ}}} where LJ&lt;:LenseOp where L&lt;:LenseOp"><code>CMBLensing.bcggd</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Branching ConjugateGradient-GradientDescent</p><p>Algortihm:     In parallel do:     a) 2 steps of gradient descent with Ncg steps of conjugate gradient towards H⁻¹g at each iteration     b) 1 steps of gradient descent with β*Ncg steps of conjugate gradient towards H⁻¹g</p><pre class="language-none"><code class="language-none">Take whichever is a lower lnP. If we take (b), then update Ncg = β*Ncg. 

β is chosen such that (a) and (b) take roughly the same ammount of time to
compute (usually β≈2 but could be higher if there&#39;s alot of overhead for a GD step)</code></pre><p>Arguments:</p><ul><li>t : which parametrization to use (i.e. t=0 for unlensed or t=1 for lensed)</li><li>fₜϕ_start : fₜϕ to start at</li><li>Nsteps : how many iterations of the above algorithm to do</li><li>Ncg : the starting value of Ncg</li><li>β : scaling factor described above</li><li>L : Lensing operator to use for gradient descent</li><li>LJ : Lensing operator to use for the Hessian calculation</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/minimize.jl#L158-L179">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.cg" href="#CMBLensing.cg"><code>CMBLensing.cg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Simple generic conjugate gradient implementation that works on Vectors, Fields, etc... </p></div></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/minimize.jl#L3-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.gdsteps-Union{Tuple{LJ}, Tuple{L}, Tuple{Any,Any,Any,Any,Any,Type{L}}, Tuple{Any,Any,Any,Any,Any,Type{L},Type{LJ}}} where LJ&lt;:LenseOp where L&lt;:LenseOp" href="#CMBLensing.gdsteps-Union{Tuple{LJ}, Tuple{L}, Tuple{Any,Any,Any,Any,Any,Type{L}}, Tuple{Any,Any,Any,Any,Any,Type{L},Type{LJ}}} where LJ&lt;:LenseOp where L&lt;:LenseOp"><code>CMBLensing.gdsteps</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Do Ngd gradient descent steps, with Ncg conjugate gradient steps towards solving H⁻¹g at each iteration.</p><p>Arguments:</p><ul><li>t : which parametrization to use (i.e. t=0 for unlensed or t=1 for lensed)</li><li>fₜϕ_cur : fₜϕ to start at</li><li>Ngd, Ncg : number of gradient descent and conjugate gradient steps</li><li>L : Lensing operator to use for gradient descent</li><li>LJ : Lensing operator to use for the Hessian calculation</li></ul><p>Returns:</p><ul><li>lnP(fₜϕ), fₜϕ, trace</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/minimize.jl#L112-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.lensing_wiener_filter-Union{Tuple{F}, Tuple{DataSet{F,TCn,TCf,TCf̃,TCϕ,TCn̂,TB̂,TM,TB,TD,TG,TP} where TP where TG where TD where TB where TM where TB̂ where TCn̂ where TCϕ where TCf̃ where TCf where TCn,Any}, Tuple{DataSet{F,TCn,TCf,TCf̃,TCϕ,TCn̂,TB̂,TM,TB,TD,TG,TP} where TP where TG where TD where TB where TM where TB̂ where TCn̂ where TCϕ where TCf̃ where TCf where TCn,Any,Any}} where F" href="#CMBLensing.lensing_wiener_filter-Union{Tuple{F}, Tuple{DataSet{F,TCn,TCf,TCf̃,TCϕ,TCn̂,TB̂,TM,TB,TD,TG,TP} where TP where TG where TD where TB where TM where TB̂ where TCn̂ where TCϕ where TCf̃ where TCf where TCn,Any}, Tuple{DataSet{F,TCn,TCf,TCf̃,TCϕ,TCn̂,TB̂,TM,TB,TD,TG,TP} where TP where TG where TD where TB where TM where TB̂ where TCn̂ where TCϕ where TCf̃ where TCf where TCn,Any,Any}} where F"><code>CMBLensing.lensing_wiener_filter</code></a> — <span class="docstring-category">Method</span>.</div><div><pre class="language-none"><code class="language-none">lensing_wiener_filter(ds::DataSet, L, which=:wf)</code></pre><p>Computes either, </p><ul><li>the Wiener filter at fixed <span>$\phi$</span>, i.e. the best-fit of</li></ul><div>\[\mathcal{P}(f\,|\,\phi,d)\]</div><ul><li>a sample from <span>$\mathcal{P}(f\,|\,\phi,d)$</span></li></ul><p>The data model assumed is, </p><div>\[d = \mathcal{M} \mathcal{B} \mathcal{L} \, f + n\]</div><p>Note that the noise is defined as un-debeamed and also unmasked (so it needs to be filled in outside the mask if using real data). The mask, <span>$\mathcal{M}$</span>, can be any composition of real and/or fourier space diagonal operators.</p><p>The argument <code>ds::DataSet</code> stores the mask, <span>$\mathcal{M}$</span>, the beam/instrumental transfer functions, <span>$\mathcal{B}$</span>, as well as the various covariances which are needed.</p><p>The <code>which</code> parameter controls which operation to do and can be one of three things:</p><ul><li><code>:wf</code> - Compute the Wiener filter</li><li><code>:sample</code> - Compute a sample from the posterior</li><li><code>:fluctuation</code> - Compute a fluctuation around the mean (i.e. a sample minus the Wiener filter)</li></ul></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/likelihood.jl#L242">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.load_sim_dataset-Tuple{}" href="#CMBLensing.load_sim_dataset-Tuple{}"><code>CMBLensing.load_sim_dataset</code></a> — <span class="docstring-category">Method</span>.</div><div><pre class="language-none"><code class="language-none">load_sim_dataset</code></pre><p>Create a <code>DataSet</code> object with some simulated data. </p></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/likelihood.jl#L484">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.noisecls-Tuple{Any}" href="#CMBLensing.noisecls-Tuple{Any}"><code>CMBLensing.noisecls</code></a> — <span class="docstring-category">Method</span>.</div><div><div><ul><li><code>μKarcminT</code>: temperature noise in μK-arcmin</li><li><code>beamFWHM</code>: beam-FWHM in arcmin</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/cls.jl#L219-L222">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.norm²-Tuple{Field,LinOp}" href="#CMBLensing.norm²-Tuple{Field,LinOp}"><code>CMBLensing.norm²</code></a> — <span class="docstring-category">Method</span>.</div><div><pre class="language-none"><code class="language-none">norm²(f::Field, L::LinOp)</code></pre><p>Shorthand for <code>f⋅(L\f)</code>, i.e. the squared-norm of <code>f</code> w.r.t. the operator <code>L</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/generic.jl#L194">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.pcg" href="#CMBLensing.pcg"><code>CMBLensing.pcg</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Preconditioned conjugate gradient. P should be symmetric and roughly √A⁻¹</p></div></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/minimize.jl#L34-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.pcg2" href="#CMBLensing.pcg2"><code>CMBLensing.pcg2</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre class="language-none"><code class="language-none">pcg2(M, A, b, x=M\b; nsteps=length(b), tol=sqrt(eps()), progress=false, callback=nothing, hist=nothing, histmod=1)</code></pre><p>Compute x = A\b (where A is positive definite) by conjugate gradient. M is the preconditioner and should approximate A, and M \ x should be fast.</p><p>The solver will stop either after <code>nsteps</code> iterations or when <code>dot(r,r)&lt;tol</code> (where <code>r=A*x-b</code> is the residual  at that step), whichever occurs first.</p><p>Info from the iterations of the solver can be returned if <code>hist</code> is specified. <code>hist</code> can be one or a tuple of:</p><ul><li><code>:i</code> - current iteration number</li><li><code>:x</code> - current solution</li><li><code>:r</code> - current residual r=A*x-b</li><li><code>:res</code> - the norm of r</li><li><code>:t</code> - the time elapsed (in seconds) since the start of the algorithm</li></ul><p><code>histmod</code> can be used to include every N-th iteration only in <code>hist</code>. </p></div></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/minimize.jl#L43-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.pixwin-Tuple{Any,Any}" href="#CMBLensing.pixwin-Tuple{Any,Any}"><code>CMBLensing.pixwin</code></a> — <span class="docstring-category">Method</span>.</div><div><pre class="language-none"><code class="language-none">pixwin(θpix, ℓ)</code></pre><p>Returns the pixel window function for square flat-sky pixels of width <code>θpix</code> (in arcmin) evaluated at some <code>ℓ</code>s. </p><p>The pixel window function is defined so that if you start with white noise at infinitely high resolution and pixelize it down a resolution <code>θpix</code>, its power spectrum will be given by pixwin(θpix, ℓ)^2. </p></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/flat.jl#L88">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.resimulate-Tuple{DataSet}" href="#CMBLensing.resimulate-Tuple{DataSet}"><code>CMBLensing.resimulate</code></a> — <span class="docstring-category">Method</span>.</div><div><pre class="language-none"><code class="language-none">resimulate(ds::DataSet; f=..., ϕ=...)</code></pre><p>Resimulate the data in a given dataset, potentially at a fixed f and/or ϕ (both are resimulate if not provided)</p></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/likelihood.jl#L69">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.sample_joint-Union{Tuple{DataSet{#s292,TCn,TCf,TCf̃,TCϕ,TCn̂,TB̂,TM,TB,TD,TG,TP} where TP where TG where TD where TB where TM where TB̂ where TCn̂ where TCϕ where TCf̃ where TCf where TCn where #s292&lt;:Union{FlatS0Fourier{T,P}, FlatS0Map{T,P}, FlatS2EBFourier{T,P}, FlatS2EBMap{T,P}, FlatS2QUFourier{T,P}, FlatS2QUMap{T,P}, FieldTuple{#s57,B,S,P} where P&lt;:PixTuple where S&lt;:SpinTuple where B&lt;:BasisTuple where #s57&lt;:Tuple{Union{FlatS0Fourier{T,P}, FlatS0Map{T,P}},Union{FlatS2EBFourier{T,P}, FlatS2EBMap{T,P}, FlatS2QUFourier{T,P}, FlatS2QUMap{T,P}}}}}, Tuple{P}, Tuple{T}} where P where T" href="#CMBLensing.sample_joint-Union{Tuple{DataSet{#s292,TCn,TCf,TCf̃,TCϕ,TCn̂,TB̂,TM,TB,TD,TG,TP} where TP where TG where TD where TB where TM where TB̂ where TCn̂ where TCϕ where TCf̃ where TCf where TCn where #s292&lt;:Union{FlatS0Fourier{T,P}, FlatS0Map{T,P}, FlatS2EBFourier{T,P}, FlatS2EBMap{T,P}, FlatS2QUFourier{T,P}, FlatS2QUMap{T,P}, FieldTuple{#s57,B,S,P} where P&lt;:PixTuple where S&lt;:SpinTuple where B&lt;:BasisTuple where #s57&lt;:Tuple{Union{FlatS0Fourier{T,P}, FlatS0Map{T,P}},Union{FlatS2EBFourier{T,P}, FlatS2EBMap{T,P}, FlatS2QUFourier{T,P}, FlatS2QUMap{T,P}}}}}, Tuple{P}, Tuple{T}} where P where T"><code>CMBLensing.sample_joint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre class="language-none"><code class="language-none">sample_joint(ds::DataSet; kwargs...)</code></pre><p>Sample from the joint PDF of P(f,ϕ,r). Runs <code>nworkers()</code> chains in parallel using <code>pmap</code>. </p><p>Possible keyword arguments: </p><ul><li><code>nsamps_per_chain</code> - the number of samples per chain</li><li><code>nchunk</code> - do <code>nchunk</code> steps in-between parallel chain communication</li><li><code>nsavemaps</code> - save maps into chain every <code>nsavemaps</code> steps</li><li><code>nburnin_always_accept</code> - the first <code>nburnin_always_accept</code> steps, always accept HMC steps independent of integration error</li><li><code>nburnin_fixθ</code> - the first <code>nburnin_fixθ</code> steps, fix θ at its starting point</li><li><code>chains</code> - resume an existing chain (starts a new one if nothing)</li><li><code>θrange</code> - range and density to grid sample parameters as a NamedTuple, e.g. <code>(Aϕ=range(0.7,1.3,length=20),)</code>. </li><li><code>θstart</code> - starting values of parameters as a NamedTuple, e.g. <code>(Aϕ=1.2,)</code>, or nothing to randomly sample from θrange</li><li><code>ϕstart</code> - starting ϕ as a Field, or <code>:quasi_sample</code> or <code>:best_fit</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/sampling.jl#L99-L117">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.sptlike_mask-Tuple{Any,Any}" href="#CMBLensing.sptlike_mask-Tuple{Any,Any}"><code>CMBLensing.sptlike_mask</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>An SPT-like mask, based mostly on,</p><p>For the boundary:</p><p>&quot;[First we] calculate the distance from the nearest masked pixel, and this distance map is smoothed using a Gaussian beam of FWHM = 15&#39;. This smoothing is applied to soften the corners of the mask. The distance map is then used to apodize the binary mask with a Gaussian beam of FWHM = 30&#39;&quot; - Omori et al. 2017</p><p>and for point sources: </p><p>&quot;The SPTpol deep field contains a number of bright point sources, which we mask. We identify all sources detected at &gt; 5σ at 150 GHz from Mocanu et al. (2013), which corresponds to a flux-cut of approximately 6 mJy; all pixels within 5&#39; of each source are masked in both the TOD filtering and the final maps. We extend this mask to 10&#39; for all very bright sources detected at &gt; 75σ. We also use a 10&#39; radius to mask all galaxy clusters de- tected in this field by Vanderlinde et al. (2010) using the Sunyaev-Zel’dovich effect. This masking removes ap- proximately 120 sources, cutting 5 deg² of the field. We additionally multiply the maps by a sky mask that down- weights the noisy edges of the maps.&quot; Story et al. 2015</p><p>Note: some of the above numbers are very slightly tweaked.</p></div></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/masking.jl#L3-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.symplectic_integrate-NTuple{5,Any}" href="#CMBLensing.symplectic_integrate-NTuple{5,Any}"><code>CMBLensing.symplectic_integrate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre class="language-none"><code class="language-none">symplectic_integrate(x₀, p₀, Λ, U, δUδx, N=50, ϵ=0.1, progress=false)</code></pre><p>Do a symplectic integration of the potential energy <code>U</code> (with gradient <code>δUδx</code>) starting from point <code>x₀</code> with momentum <code>p₀</code> and mass matrix <code>Λ</code>. The number of steps is <code>N</code> and the step size <code>ϵ</code>. </p><p>Returns <code>ΔH, xᵢ, pᵢ</code> corresponding to change in Hamiltonian, and final position and momenta. If <code>hist</code> is specified a trace of requested variables throughout each step is also returned. </p></div></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/sampling.jl#L1-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.ud_grade-Union{Tuple{P}, Tuple{∂mode}, Tuple{N}, Tuple{θ}, Tuple{T}, Tuple{Union{FlatS0Fourier{T,P}, FlatS0Map{T,P}},Any}} where P&lt;:Flat{θ,N,∂mode} where ∂mode where N where θ where T" href="#CMBLensing.ud_grade-Union{Tuple{P}, Tuple{∂mode}, Tuple{N}, Tuple{θ}, Tuple{T}, Tuple{Union{FlatS0Fourier{T,P}, FlatS0Map{T,P}},Any}} where P&lt;:Flat{θ,N,∂mode} where ∂mode where N where θ where T"><code>CMBLensing.ud_grade</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre class="language-none"><code class="language-none">ud_grade(f::Field, θnew, mode=:map, deconv_pixwin=true, anti_aliasing=true)</code></pre><p>Up- or down-grades field <code>f</code> to new resolution <code>θnew</code> (only in integer steps). Two modes are available specified by the <code>mode</code> argument: </p><pre class="language-none"><code class="language-none">*`:map`     : Up/downgrade by replicating/averaging pixels in map-space
*`:fourier` : Up/downgrade by extending/truncating the Fourier grid</code></pre><p>For <code>:map</code> mode, two additional options are possible. If <code>deconv_pixwin</code> is true, deconvolves the pixel window function from the downgraded map so the spectrum of the new and old maps are the same. If <code>anti_aliasing</code> is true, filters out frequencies above Nyquist prior to down-sampling. </p></div></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/flat_s0.jl#L85-L99">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.ϕqe" href="#CMBLensing.ϕqe"><code>CMBLensing.ϕqe</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre class="language-none"><code class="language-none">ϕqe(d, Cf, Cf̃, Cn, Cϕ=nothing)</code></pre><p>Compute quadratic estimate for ϕ given data. </p><ul><li><code>d</code> - data</li><li><code>Cf, Cf̃</code> - unlensed and lensed <em>beamed</em> theory covariances</li><li><code>Cn</code> - noise covariance (beam <em>not</em> deconvolved)</li><li><code>Cϕ</code> - (optional) lensing potential theory covariance. if provided, the result        is Wiener filtered, otherwise the unbiased estimate is retured. </li></ul><p>Returns a tuple of <code>(ϕqe, Nϕ)</code> where <code>ϕqe</code> is the quadratic estimate and <code>Nϕ</code> is the N0 noise bias.</p></div></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/quadratic_estimate.jl#L3-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="PyPlot.plot-Tuple{Field}" href="#PyPlot.plot-Tuple{Field}"><code>PyPlot.plot</code></a> — <span class="docstring-category">Method</span>.</div><div><pre class="language-none"><code class="language-none">plot(f::Field; kwargs...)
plot(fs::VecOrMat{\&lt;:Field}; kwarg...)</code></pre><p>Plotting fields. </p></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/plotting.jl#L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.Mnyq-Union{Tuple{P}, Tuple{N}, Tuple{θ}, Tuple{T}, Tuple{Type{T},Type{P},Any}} where P&lt;:(Flat{θ,N,∂mode} where ∂mode&lt;:CMBLensing.∂modes) where N where θ where T" href="#CMBLensing.Mnyq-Union{Tuple{P}, Tuple{N}, Tuple{θ}, Tuple{T}, Tuple{Type{T},Type{P},Any}} where P&lt;:(Flat{θ,N,∂mode} where ∂mode&lt;:CMBLensing.∂modes) where N where θ where T"><code>CMBLensing.Mnyq</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>filter out the single row/column in the real FFT matrix <code>M</code> which corresponds to exactly the nyquist frequency </p></div></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/flat.jl#L77-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.antilensing-Union{Tuple{PowerLens{N,F}}, Tuple{F}, Tuple{N}} where F where N" href="#CMBLensing.antilensing-Union{Tuple{PowerLens{N,F}}, Tuple{F}, Tuple{N}} where F where N"><code>CMBLensing.antilensing</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Create from an existing PowerLens operator one that lenses by -ϕ instead. </p></div></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/powerlens.jl#L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.camb_cl_files-Tuple{Any}" href="#CMBLensing.camb_cl_files-Tuple{Any}"><code>CMBLensing.camb_cl_files</code></a> — <span class="docstring-category">Method</span>.</div><div><pre class="language-none"><code class="language-none">camb_cl_files(filename_root)</code></pre><p>Loads Cℓ&#39;s from some CAMB output files. <code>filename_root</code> should be such that $(filename<em>root)</em>scalCls.dat, etc... are the CAMB data files.</p></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/cls.jl#L126">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.fftsyms-Union{Tuple{n}, Tuple{m}, Tuple{Type{Val{m}},Type{Val{n}}}} where n where m" href="#CMBLensing.fftsyms-Union{Tuple{n}, Tuple{m}, Tuple{Type{Val{m}},Type{Val{n}}}} where n where m"><code>CMBLensing.fftsyms</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Arguments m and n refer to the sizes of an m×n matrix (call it A) that is the output of a real FFT (thus m=n÷2+1)</p><p>Returns a tuple of (ireal, iimag, negks) where these are</p><pre class="language-none"><code class="language-none">* ireal - m×n mask corrsponding to unique real entries of A
* iimag - m×n mask corrsponding to unique imaginary entries of A
* negks - m×n matrix of giving the index into A where the negative k-vector
          is, s.t. A[i,j] = A[negks[i,j]]&#39;</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/rfftvectors.jl#L53-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.fieldvalues-Tuple{Any}" href="#CMBLensing.fieldvalues-Tuple{Any}"><code>CMBLensing.fieldvalues</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Return the type&#39;s fields as a tuple</p></div></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/util.jl#L7-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.full-Union{Tuple{Fout}, Tuple{Fin}, Tuple{Type{Fin},Type{Fout},LinOp}} where Fout&lt;:Field where Fin&lt;:Field" href="#CMBLensing.full-Union{Tuple{Fout}, Tuple{Fin}, Tuple{Type{Fin},Type{Fout},LinOp}} where Fout&lt;:Field where Fin&lt;:Field"><code>CMBLensing.full</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre class="language-none"><code class="language-none">full(::Type{Fin}, ::Type{Fout}, L::LinOp; progress=true)
full(::Type{F}, L::LinOp; progress=true)</code></pre><p>Construct an explicit matrix representation of the linear operator <code>L</code> by applying it to a set of vectors which form a complete basis. The <code>Fin</code> and <code>Fout</code> types should be fields which specify the input and output bases for the representation (or just <code>F</code> if <code>L</code> is square and we want the same input/output bases)</p><p>The name <code>full</code> is to be consistent with Julia&#39;s SparseArrays where <code>full</code> builds a full matrix from a sparse one.</p></div></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/generic.jl#L174-L186">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.rfft2vec-Tuple{AbstractArray{T,2} where T}" href="#CMBLensing.rfft2vec-Tuple{AbstractArray{T,2} where T}"><code>CMBLensing.rfft2vec</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Convert a matrix A which is the output of a real FFT to a real vector, keeping only unqiue real/imaginary entries of A</p></div></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/rfftvectors.jl#L2-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.unfold-Union{Tuple{AbstractArray{Complex{T},2}}, Tuple{T}} where T" href="#CMBLensing.unfold-Union{Tuple{AbstractArray{Complex{T},2}}, Tuple{T}} where T"><code>CMBLensing.unfold</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Convert an M×N matrix (with M=N÷2+1) which is the output a real FFT to a full N×N one via symmetries.</p></div></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/rfftvectors.jl#L32-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.vec2rfft-Tuple{AbstractArray{#s21,1} where #s21&lt;:Real}" href="#CMBLensing.vec2rfft-Tuple{AbstractArray{#s21,1} where #s21&lt;:Real}"><code>CMBLensing.vec2rfft</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Convert a vector produced by rfft2vec back into a complex matrix.</p></div></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/rfftvectors.jl#L12-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.Σ-Union{Tuple{L}, Tuple{Any,Any}, Tuple{Any,Any,Type{L}}} where L" href="#CMBLensing.Σ-Union{Tuple{L}, Tuple{Any,Any}, Tuple{Any,Any,Type{L}}} where L"><code>CMBLensing.Σ</code></a> — <span class="docstring-category">Method</span>.</div><div><pre class="language-none"><code class="language-none">Σ(ϕ, ds, ::Type{L}=LenseFlow) where {L}
Σ(L::LenseOp, ds)</code></pre><p>Operator for the data covariance, Cn + P<em>M</em>B<em>L</em>Cf<em>L&#39;</em>B&#39;<em>M&#39;</em>P&#39;, which can applied and inverted.</p></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/likelihood.jl#L297">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.δf̃_δf-Tuple{PowerLens,Any}" href="#CMBLensing.δf̃_δf-Tuple{PowerLens,Any}"><code>CMBLensing.δf̃_δf</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>δf̃(f,ϕ)/δf * v </p></div></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/powerlens.jl#L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.δf̃_δfᴴ-Union{Tuple{N}, Tuple{PowerLens{N,F} where F&lt;:(Field{#s57,#s56,P} where P&lt;:Pix where #s56&lt;:S0 where #s57),Field}} where N" href="#CMBLensing.δf̃_δfᴴ-Union{Tuple{N}, Tuple{PowerLens{N,F} where F&lt;:(Field{#s57,#s56,P} where P&lt;:Pix where #s56&lt;:S0 where #s57),Field}} where N"><code>CMBLensing.δf̃_δfᴴ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>(δf̃(f,ϕ)/δf)ᴴ * v </p></div></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/powerlens.jl#L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.δf̃_δϕ-Union{Tuple{F}, Tuple{N}, Tuple{PowerLens{N,F} where F&lt;:(Field{#s57,#s56,P} where P&lt;:Pix where #s56&lt;:S0 where #s57),F,Field}} where F&lt;:Field where N" href="#CMBLensing.δf̃_δϕ-Union{Tuple{F}, Tuple{N}, Tuple{PowerLens{N,F} where F&lt;:(Field{#s57,#s56,P} where P&lt;:Pix where #s56&lt;:S0 where #s57),F,Field}} where F&lt;:Field where N"><code>CMBLensing.δf̃_δϕ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>δf̃(f,ϕ)/δϕ * v </p></div></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/powerlens.jl#L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.δf̃_δϕᴴ-Union{Tuple{F}, Tuple{N}, Tuple{PowerLens{N,F},Field,Field}} where F where N" href="#CMBLensing.δf̃_δϕᴴ-Union{Tuple{F}, Tuple{N}, Tuple{PowerLens{N,F},Field,Field}} where F where N"><code>CMBLensing.δf̃_δϕᴴ</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>(δf̃(f,ϕ)/δϕ)ᴴ * v </p></div></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/powerlens.jl#L88">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.δ²f̃_δϕ²-Union{Tuple{F}, Tuple{N}, Tuple{PowerLens{N,F},Field,Field,Field}} where F where N" href="#CMBLensing.δ²f̃_δϕ²-Union{Tuple{F}, Tuple{N}, Tuple{PowerLens{N,F},Field,Field,Field}} where F where N"><code>CMBLensing.δ²f̃_δϕ²</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Compute wᴴ * δ²f̃(f,ϕ)/δϕ² * v </p></div></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/powerlens.jl#L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMBLensing.jrk4-Tuple{Function,Any,Any,Any,Any}" href="#CMBLensing.jrk4-Tuple{Function,Any,Any,Any,Any}"><code>CMBLensing.jrk4</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Solve for y(t₁) with 4th order Runge-Kutta assuming dy/dt = F(t,y) and y(t₀) = y₀</p><p>Arguments</p><ul><li>F! : a function F!(v,t,y) which sets v=F(t,y)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/marius311/CMBLensing.jl/blob/a2aaf5c6b1e15735a3812548f7f72c0dc4fc2127/src/lenseflow.jl#L146-L151">source</a></section><footer><hr/><a class="previous" href="../joint_MAP_example/"><span class="direction">Previous</span><span class="title">Joint maximum a posterior estimate</span></a></footer></article></body></html>
