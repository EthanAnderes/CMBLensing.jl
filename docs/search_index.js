var documenterSearchIndex = {"docs": [

{
    "location": "#",
    "page": "CMBLensing.jl",
    "title": "CMBLensing.jl",
    "category": "page",
    "text": ""
},

{
    "location": "#CMBLensing.jl-1",
    "page": "CMBLensing.jl",
    "title": "CMBLensing.jl",
    "category": "section",
    "text": "This repository contains tools written in Julia to analyze the gravitationally lensed Cosmic Microwave Background. Some things this code can do:Lense flat-sky temperature and polarization maps using the following algorithms:\nTaylor series expansion to any order\nThe Taylens algorithm (Næss & Louis 2013)\nThe LenseFlow algorithm (Millea, Anderes, & Wandelt 2017)\nCompute the quadratic estimate of phi given some data (Hu & Okamoto 2003)\nCompute best-fit of mathcalP(fphid), i.e. the joint maximum a posteriori estimate of the lensing potential and CMB fields, and draw Monte-Carlo samples from this poterior, with the option to sample over cosmological parameters as well (Millea, Anderes, & Wandelt 2017)\nCompute best-fit of mathcalP(phid), i.e. the marginal maximum a posteriori estimate of the lensing potential (Carron & Lewis 2017)"
},

{
    "location": "#Documentation-1",
    "page": "CMBLensing.jl",
    "title": "Documentation",
    "category": "section",
    "text": "The best place to get started is to read the documentation (which is very much a work-in-progress, many things this package can do are not documented yet, but are planned to be added soon). Most of the pages in the documentation are Jupyter notebooks which you can find in this folder, which you can run yourself. "
},

{
    "location": "#Requirements-1",
    "page": "CMBLensing.jl",
    "title": "Requirements",
    "category": "section",
    "text": "Julia 1.0 or higher\nPython 3 + matplotlib (used for plotting)\n(optional) pycamb to be able to generate C_ell\'s\n(optional) healpy for experimental curved sky support"
},

{
    "location": "#Native-installation-1",
    "page": "CMBLensing.jl",
    "title": "Native installation",
    "category": "section",
    "text": "To install the Julia package locally, run:pkg> dev https://github.com/marius311/CMBLensing.jl(type ] at the Julia REPL to reach the pkg> prompt)"
},

{
    "location": "#Run-via-Docker-1",
    "page": "CMBLensing.jl",
    "title": "Run via Docker",
    "category": "section",
    "text": "Also provided is a Docker container which includes a Jupyter notebook server and all the dependencies to run and use CMBLensing.jl. This is probably the quickest way to get up and running including all of the optional dependencies (you just need Docker and docker-compose on your system). To launch the Jupyter notebook, clone this repository and run the following from the root directory,docker-compose pull\ndocker-compose upThe first time you run this, it will automatically download the (~500Mb) container from the Docker hub. The command will prompt you with the URL which you should open in a browser to access the notebook.To run the notebook on a different port than the default 8888, do PORT=1234 docker-compose up where 1234 is whatever port number you want.You can also build the container locally by replacing docker-compose pull with docker-compose build above."
},

{
    "location": "lense_a_map/#",
    "page": "Lensing a flat map",
    "title": "Lensing a flat map",
    "category": "page",
    "text": ""
},

{
    "location": "lense_a_map/#Lensing-a-flat-map-1",
    "page": "Lensing a flat map",
    "title": "Lensing a flat map",
    "category": "section",
    "text": "using CMBLensingFirst we load a simulated unlensed field, f, and lensing potential, phi,@unpack f,ϕ = load_sim_dataset(\n    θpix  = 2,       # size of the pixels in arcmin\n    Nside = 256,     # number of pixels per side in the map\n    T     = Float32, # Float32 or Float64 (former is ~twice as fast)\n    use   = :T       # :T for temperature, :P for polarization, or :TP for both\n);We can lense the map with LenseFlow,f̃ = LenseFlow(ϕ) * f;And flip between lensed and unlensed maps,animate([f,f̃], motionblur=false, interval=500)<video width=\"560\" height=\"400\" controls autoplay loop>\n  <source type=\"video/mp4\" src=\"data:video/mp4;base64,AAAAHGZ0eXBNNFYgAAACAGlzb21pc28yYXZjMQAAAAhmcmVlAACwnW1kYXQAAAKuBgX//6rcRem9\n5tlIt5Ys2CDZI+7veDI2NCAtIGNvcmUgMTUyIHIyODU0IGU5YTU5MDMgLSBILjI2NC9NUEVHLTQg\nQVZDIGNvZGVjIC0gQ29weWxlZnQgMjAwMy0yMDE3IC0gaHR0cDovL3d3dy52aWRlb2xhbi5vcmcv\neDI2NC5odG1sIC0gb3B0aW9uczogY2FiYWM9MSByZWY9MyBkZWJsb2NrPTE6MDowIGFuYWx5c2U9\nMHgzOjB4MTEzIG1lPWhleCBzdWJtZT03IHBzeT0xIHBzeV9yZD0xLjAwOjAuMDAgbWl4ZWRfcmVm\nPTEgbWVfcmFuZ2U9MTYgY2hyb21hX21lPTEgdHJlbGxpcz0xIDh4OGRjdD0xIGNxbT0wIGRlYWR6\nb25lPTIxLDExIGZhc3RfcHNraXA9MSBjaHJvbWFfcXBfb2Zmc2V0PS0yIHRocmVhZHM9MTIgbG9v\na2FoZWFkX3RocmVhZHM9MiBzbGljZWRfdGhyZWFkcz0wIG5yPTAgZGVjaW1hdGU9MSBpbnRlcmxh\nY2VkPTAgYmx1cmF5X2NvbXBhdD0wIGNvbnN0cmFpbmVkX2ludHJhPTAgYmZyYW1lcz0zIGJfcHly\nYW1pZD0yIGJfYWRhcHQ9MSBiX2JpYXM9MCBkaXJlY3Q9MSB3ZWlnaHRiPTEgb3Blbl9nb3A9MCB3\nZWlnaHRwPTIga2V5aW50PTI1MCBrZXlpbnRfbWluPTIgc2NlbmVjdXQ9NDAgaW50cmFfcmVmcmVz\naD0wIHJjX2xvb2thaGVhZD00MCByYz1jcmYgbWJ0cmVlPTEgY3JmPTIzLjAgcWNvbXA9MC42MCBx\ncG1pbj0wIHFwbWF4PTY5IHFwc3RlcD00IGlwX3JhdGlvPTEuNDAgYXE9MToxLjAwAIAAAJBiZYiE\nABT//vfHT8Cm6Plmy51FPSEwitj6SCi/nf+NjjwgAHEqHQ2JG26LpBne3XOIquosR6tGMfUIZuGy\n184pM+riRQpQzbo1LzRAocwQGyhXAkgWf8fQY20CM6LDjml2CATObHpnxaGNDf4y+No1nbzjgVwN\nk8aEFMJObB1fQaoVNszm1yo7kTQ7/il+kCP///eLaGEIs0MWdkrK1oruKCxKP95fxrQQK56/hU3z\n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\n\">\n  Your browser does not support the video tag.\n</video>The difference between lensed and unlensed,plot(f-f̃);(Image: png)"
},

{
    "location": "lense_a_map/#Loading-your-own-data-1",
    "page": "Lensing a flat map",
    "title": "Loading your own data",
    "category": "section",
    "text": "CMBLensing flat-sky Field objects like f or ϕ  are just thin wrappers around arrays. You can get the underlying data arrays for I(mathbfx), Q(mathbfx), and U(mathbfx) with f.Ix, f.Qx, and f.Ux respectively, or the Fourier coefficients, I(mathbfl), Q(mathbfl), and U(mathbfl) with f.Il, f.Ql, and f.Ul,mapdata = f.Tx256×256 Array{Float32,2}:\n  -79.5587   -80.4108   -94.6614  …  -128.877   -105.043    -87.6131\n -109.411    -97.0429  -101.171      -154.201   -140.864   -126.532 \n -131.794   -113.477   -105.807      -164.485   -160.23    -149.272 \n -136.139   -117.988   -103.488      -170.719   -167.458   -153.629 \n -121.269   -103.887    -90.5891     -179.142   -171.064   -146.952 \n -106.169    -87.2436   -75.5778  …  -176.773   -165.659   -136.533 \n  -99.8212   -76.6555   -60.2086     -162.67    -150.592   -126.5   \n  -93.0231   -65.574    -42.8354     -146.739   -136.22    -117.785 \n  -88.8041   -60.1645   -32.1262     -134.539   -125.07    -110.763 \n  -91.9297   -66.8561   -36.721      -122.929   -114.289   -106.158 \n  -97.8625   -80.7938   -55.8878  …  -113.502   -108.411   -105.879 \n  -97.3983   -87.1153   -73.4966     -105.553   -106.101   -105.788 \n  -91.7292   -84.0579   -79.0743     -100.48    -104.433   -103.216 \n    ⋮                             ⋱                           ⋮     \n -205.279   -175.424   -144.777      -153.674   -184.447   -208.177 \n -220.501   -192.189   -163.713   …  -174.699   -202.278   -224.144 \n -237.225   -208.973   -181.995      -199.383   -222.152   -240.671 \n -241.089   -218.507   -196.842      -209.294   -226.567   -242.285 \n -224.224   -213.454   -197.285      -195.606   -206.988   -219.71  \n -187.087   -189.171   -178.031      -169.356   -172.75    -178.429 \n -137.231   -149.028   -144.832   …  -150.167   -138.66    -129.939 \n  -83.9273   -99.6773  -105.83       -132.704   -107.35     -84.007 \n  -41.4026   -56.1798   -72.321      -105.874    -76.6227   -49.0623\n  -23.9573   -39.0729   -59.4268      -85.8399   -55.4256   -30.0764\n  -30.3424   -48.2696   -67.4385      -84.9029   -52.8358   -29.4172\n  -50.9027   -64.466    -83.0583  …  -101.137    -70.8866   -50.355If you have your own map data in an array you\'d like to load into a CMBLensing Field object, you can construct it as follows:FlatS0Map(mapdata, θpix=3)FlatS0Map{Float32,Flat{3,256,fourier∂}}(Float32[-79.5587 -80.4108 … -105.043 -87.6131; -109.411 -97.0429 … -140.864 -126.532; … ; -30.3424 -48.2696 … -52.8358 -29.4172; -50.9027 -64.466 … -70.8866 -50.355])"
},

{
    "location": "lense_a_map/#Inverse-lensing-1",
    "page": "Lensing a flat map",
    "title": "Inverse lensing",
    "category": "section",
    "text": "You can inverse lense a map with the \\ operator (which does A \\ b ≡ inv(A) * b):LenseFlow(ϕ) \\ f;Note that this is true inverse lensing, rather than lensing by the negative deflection (which is often called \"anti-lensing\"). This means that lensing then inverse lensing a map should get us back the original map. Lets check that this is the case:Ns = [7 10 20]\nplot([f - (LenseFlow(ϕ,N) \\ (LenseFlow(ϕ,N) * f)) for N in Ns],\n    title=[\"ODE steps = $N\" for N in Ns]);(Image: png)A cool feature of LenseFlow is that inverse lensing is trivially done by running the LenseFlow ODE in reverse. Note that as we crank up the number of ODE steps, we recover the original map to higher and higher precision."
},

{
    "location": "lense_a_map/#Other-lensing-algorithms-1",
    "page": "Lensing a flat map",
    "title": "Other lensing algorithms",
    "category": "section",
    "text": "We can also lense via:PowerLens: the standard Taylor series expansion to any order: f(x+nabla x) approx f(x) + (nabla f)(nabla phi) + frac12 (nabla nabla f) (nabla phi)^2 +  TayLens (Næss&Louis 2013): like PowerLens, but first a nearest-pixel permute step, then a Taylor expansion around the now-smaller residual displacementplot([(PowerLens(ϕ,7)*f - f̃) (Taylens(ϕ,2)*f - f̃)], \n    title=[\"PowerLens - LenseFlow\" \"TayLens - LenseFlow\"]);(Image: png)"
},

{
    "location": "lense_a_map/#Benchmarking-1",
    "page": "Lensing a flat map",
    "title": "Benchmarking",
    "category": "section",
    "text": "LenseFlow is highly optimized code since it appears on the inner-most loop of our analysis algorithms. To benchmark LenseFlow, note that there is first a precomputation step, which caches some data in preparation for applying it to a field of a given type. This was done automatically when evaluating LenseFlow(ϕ) * f but we can benchmark it separately since in many cases this only needs to be done once for a given phi, e.g. when Wiener filtering at fixed phi,using BenchmarkTools@benchmark cache(LenseFlow(ϕ),f)BenchmarkTools.Trial: \n  memory estimate:  102.36 MiB\n  allocs estimate:  2558\n  --------------\n  minimum time:     26.845 ms (35.77% GC)\n  median time:      49.447 ms (61.57% GC)\n  mean time:        81.033 ms (75.67% GC)\n  maximum time:     192.036 ms (86.06% GC)\n  --------------\n  samples:          62\n  evals/sample:     1Once cached, it\'s very fast and memory non-intensive to repeatedly apply the operator:@benchmark $Lϕ * $f setup=(Lϕ=cache(LenseFlow(ϕ),f))BenchmarkTools.Trial: \n  memory estimate:  2.13 MiB\n  allocs estimate:  2633\n  --------------\n  minimum time:     12.761 ms (0.00% GC)\n  median time:      14.263 ms (0.00% GC)\n  mean time:        20.589 ms (0.00% GC)\n  maximum time:     61.831 ms (0.00% GC)\n  --------------\n  samples:          40\n  evals/sample:     1"
},

{
    "location": "posterior/#",
    "page": "The Lensing Posterior",
    "title": "The Lensing Posterior",
    "category": "page",
    "text": ""
},

{
    "location": "posterior/#The-Lensing-Posterior-1",
    "page": "The Lensing Posterior",
    "title": "The Lensing Posterior",
    "category": "section",
    "text": "Much of what the CMBLensing package does is centered on the \"CMB lensing posterior\". We refer to either the \"joint posterior\",  mathcalP(fphithetad) wheref are the CMB fields (T/Q/U)\nphi is the lensing potential\ntheta are any cosmological parameters\nd is the data,or the \"marginal posterior\",  mathcalP(phithetad) equiv int  mathcalDf  mathcalP(fphithetad) which is simply the joint posterior marginalized over f. We assume the following data model, which is generally flexible enough to handle real experiments: d = mathbbP  mathbbM  mathbbB  mathbbL(phi)  f + n where mathbbL(phi) is the lensing operation\nmathbbB is an instrumental transfer function or \"beam\"\nmathbbM is a user-chosen mask\nmathbbP is a pixelization operation which allows one to estimate f on a higher resolution than the data\nn is the instrumental noise. Given this model, the joint posterior (up to an unimportant normalization constant) in the \"unlensed parameterization\", is: \n-2lnmathcalP(fphithetad) = fracbig(d - mathbbP  mathbbM  mathbbB  mathbbL(phi)  fbig)^2mathbbC_n\n+ fracf^2mathbbC_f(theta) + fracphi^2C_phi(theta) + logdet mathbbC_f(theta) + logdet C_phi(theta)\nwheremathbbC_n is the noise covariance\nmathbbC_f is the CMB covariance (i.e. the CMB T, E, and B C_ell\'s)\nmathbbC_phi is the lensing potential covariance (i.e. C_ell^phiphi)and we have used the slighly sloppy notation x^2mathbbC to mean x^dagger mathbbC^-1 x.It\'s often useful to parameterize this in terms of the lensed tilde f = mathbbL(phi) f (this reduces correlations), in which case we have the \"\"lensed parametrization\": \n-2lnmathcalP(tilde fphithetad) = fracbig(d - mathbbP  mathbbM  mathbbB  tilde fbig)^2mathbbC_n\n+ fracbig(mathbbL(phi)^-1 tilde fbig)^2mathbbC_f(theta) + fracphi^2C_phi(theta) + logdet mathbbC_f(theta) + logdet C_phi(theta)\n"
},

{
    "location": "posterior/#Posterior-basics-1",
    "page": "The Lensing Posterior",
    "title": "Posterior basics",
    "category": "section",
    "text": "CMBLensing uses the function lnP to compute the log of the joint posterior probability.using CMBLensinglnPlnP (generic function with 9 methods)To evaluate this posterior, we need the arguments of the probability distribution, f, phi, and theta. We also need the data d and host of other operators and covariances which enter the expressions above, which CMBLensing stores in a DataSet object.First lets load up some simulated data. We\'ll use 1muK-arcmin noise and a border mask:@unpack f, ϕ, ds = load_sim_dataset(\n    θpix      = 2,\n    Nside     = 256,\n    T         = Float32,\n    use       = :P,\n    μKarcminT = 1,\n    mask_kwargs = (paddeg=1, nsources=0)\n);The DataSet object, ds, stores all the aforementioned quantities:fieldnames(typeof(ds))(:d, :Cn, :Cϕ, :Cf, :Cf̃, :Cn̂, :M, :B, :B̂, :D, :G, :P)For example, the data is:plot(ds.d);(Image: png)We can now evaluate the posterior, for example at the true f and phi:-2*lnP(0, f, ϕ, ds)306882.90319405496The first argument, 0, indicates that this is in the unlensed parameterization. We could also use 1 for the lensed parametriation. (The 0 and 1 refer to auxillary \"time\" variable in the LenseFlow expansion, f(x+tnablaphi); at t=0 we have the unlensed field, and at t=1 we have the lensed field). If we use the lensed parametrization, then the f argument to the function is expected to be the lensed field.-2*lnP(1, LenseFlow(ϕ)*f, ϕ, ds)307156.48902226775Any difference between these two is due only to the error in the LenseFlow inverse operation. The difference we see here is fine, but in theory we can make the difference arbitrarily small by cranking up the number of LenseFlow ODE steps:let L = LenseFlow(ϕ,30)\n    -2*lnP(1, L*f, ϕ, ds, L)\nend306882.88420174696We expect minus twice the posterior evaluated at the truth to be distributed like a chi^2 distribution where the degrees of freedom equals the number of pixels in d, f, and phi (i.e. in each of the three Gaussian terms in the posterior). Since these maps are 256x256 and d and f have both Q and U maps, this is:(2+2+1)*256^2327680which the previous result is within a few sigma of.Above, we didn\'t specify any cosmological parameters, theta. Because of that, they were fixed at their fiducial values (i.e. the fiducial values which generated the simulated data in the call to load_sim_dataset earlier). Current only two parameters can be varied, r (tensor-to-scalar ratio), and A_phi (the amplitude of C_ell^phi phi). They can be specified as follows, with non-specified parameters left at their fiducial:-2*lnP(0, f, ϕ, (Aϕ=1.1,), ds)307200.19728863984You can see the slight change compared to what we got above. We can even compute a whole slice through the posterior along A_phi:Aϕs = range(0.5,1.5,length=50)\nplot(Aϕs, [lnP(0, f, ϕ, (Aϕ=Aϕ,), ds) for Aϕ in Aϕs])\nxlabel(raw\"$A_\\phi$\")\nylabel(raw\"$\\mathcal{P}(f_{\\rm true}, \\phi_{\\rm true}, A_\\phi\\,|\\,d)$\");(Image: png)"
},

{
    "location": "posterior/#Wiener-filtering-1",
    "page": "The Lensing Posterior",
    "title": "Wiener filtering",
    "category": "section",
    "text": "If we fix phi and theta then maximize the joint posterior, mathcalP(fphithetad), over f, we get\nhat f_rm wf = big mathbbC_f(theta)^-1 + mathbbA^daggermathbbC_n^-1mathbbA big^-1 mathbbA^daggermathbbC_n^-1d\nwhere\nmathbbA = mathbbM  mathbbP  mathbbB  mathbbL(phi)\nThis is simply the Wiener filter of the data, and we can compute it by inverting the operator in brackets above with e.g. Conjugate Gradient. In CMBLensing, the argmaxf_lnP function performs this task. Its arguments are similar to lnP,f_wf = argmaxf_lnP(ϕ, (Aϕ=1,), ds, progress=true)[32mConjugate Gradient: 100%|███████████████████████████████| Time: 0:00:50[39mSince Wiener filtering is the best-fit of the joint posterior at a fixed phi, it is effectively delensing the data by a given phi. Here we are Wiener filtering at the true phi, so this is perfect delensing. Note below the large amount of B mode power in the data, as well as the aliasing near the border mask, and how this is removed in the Wiener filtered B, which visually is tracing the true B map up to the level of the noise.plot([ds.d, f_wf, f], title=[\"data \", \"Wiener filtered \", \"true \"] .* [\"E\" \"B\"]);(Image: png)"
},

{
    "location": "posterior/#Posterior-gradients-1",
    "page": "The Lensing Posterior",
    "title": "Posterior gradients",
    "category": "section",
    "text": ""
},

{
    "location": "posterior/#Marginal-posterior-1",
    "page": "The Lensing Posterior",
    "title": "Marginal posterior",
    "category": "section",
    "text": ""
},

{
    "location": "joint_MAP_example/#",
    "page": "Joint maximum a posterior estimate",
    "title": "Joint maximum a posterior estimate",
    "category": "page",
    "text": ""
},

{
    "location": "joint_MAP_example/#Joint-maximum-a-posterior-estimate-1",
    "page": "Joint maximum a posterior estimate",
    "title": "Joint maximum a posterior estimate",
    "category": "section",
    "text": "using CMBLensing\nusing PyPlot"
},

{
    "location": "joint_MAP_example/#Compute-spectra-1",
    "page": "Joint maximum a posterior estimate",
    "title": "Compute spectra",
    "category": "section",
    "text": "First, compute the fiducial CMB power spectra which generate our simulated data,Cℓ = camb(r=0.05);Next, chose the noise power-spectra we are assuming,Cℓn = noisecls(1, ℓknee=100);Plot these up for reference,loglog(Cℓ[:f̃][:BB],c=\"C0\")\nloglog(Cℓ[:f][:BB],\"--\",c=\"C0\")\nloglog(Cℓ[:f̃][:EE],c=\"C1\")\nloglog(Cℓ[:f][:EE],\"--\",c=\"C1\")\nloglog(Cℓn[:BB],\"k:\")\nlegend([\"lensed B\",\"unlensed B\",\"lensed E\",\"unlensed E\", \"noise (beam not deconvolved)\"]);(Image: png)"
},

{
    "location": "joint_MAP_example/#Configure-the-type-of-data-1",
    "page": "Joint maximum a posterior estimate",
    "title": "Configure the type of data",
    "category": "section",
    "text": "These describe the setup of the simulated data we are going to work with (and can be changed),Θpix  = 3        # pixel size in arcmin\nNside = 128      # number of pixels per side in the map\nuse   = :P       # type of data to use (can be :T, :P, or :TP)\nT     = Float32  # data type (Float32 is ~2 as fast as Float64);"
},

{
    "location": "joint_MAP_example/#Generate-simulated-data-1",
    "page": "Joint maximum a posterior estimate",
    "title": "Generate simulated data",
    "category": "section",
    "text": "With these defined, the following generates the simulated data and returns the true unlensed and lensed CMB fields, f and f̃ ,and the true lensing potential, ϕ, as well as a number of other quantities stored in the \"DataSet\" object ds. @unpack f, f̃, ϕ, ds = load_sim_dataset(\n    seed = 3,\n    Cℓ = Cℓ,\n    Cℓn = Cℓn,\n    θpix = Θpix,\n    T = T,\n    Nside = Nside,\n    use = use,\n)\n\n@unpack Cf, Cϕ = ds;"
},

{
    "location": "joint_MAP_example/#Examine-simulated-data-1",
    "page": "Joint maximum a posterior estimate",
    "title": "Examine simulated data",
    "category": "section",
    "text": "The true phi map,plot(ϕ, title = raw\"true $\\phi$\");(Image: png)The \"true\" unlensed field, f,plot(f, title = \"true unlensed \" .* [\"E\" \"B\"]);(Image: png)And the \"true\" lensed field,plot(LenseFlow(ϕ)*f, title = \"true lensed \" .* [\"E\" \"B\"]);(Image: png)The data (stored in the ds object) is basically f̃ with a beam applied plus a sample of the noise,plot(ds.d, title = \"data \" .* [\"E\" \"B\"]);(Image: png)"
},

{
    "location": "joint_MAP_example/#Run-the-minimizer-1",
    "page": "Joint maximum a posterior estimate",
    "title": "Run the minimizer",
    "category": "section",
    "text": "Now we compute the maximum of the joint posterior, mathcalPbig(f phi bigdbig)@time fbf, ϕbf, tr = MAP_joint(ds, nsteps=30, progress=true, αmax=0.3);(step=1, χ²=43095.79, Ncg=5)\n(step=2, χ²=37543.49, Ncg=7, α=0.014462)\n(step=3, χ²=35741.61, Ncg=6, α=0.023435)\n(step=4, χ²=35070.68, Ncg=6, α=0.014318)\n(step=5, χ²=34555.49, Ncg=6, α=0.026880)\n(step=6, χ²=34267.12, Ncg=6, α=0.012814)\n(step=7, χ²=33964.64, Ncg=6, α=0.036058)\n(step=8, χ²=33789.71, Ncg=6, α=0.010863)\n(step=9, χ²=33504.85, Ncg=6, α=0.069608)\n(step=10, χ²=33369.26, Ncg=6, α=0.009044)\n(step=11, χ²=32967.68, Ncg=6, α=0.229131)\n(step=12, χ²=32906.38, Ncg=5, α=0.008829)\n(step=13, χ²=32867.10, Ncg=5, α=0.073871)\n(step=14, χ²=32845.12, Ncg=5, α=0.009594)\n(step=15, χ²=32777.38, Ncg=5, α=0.223282)\n(step=16, χ²=32750.20, Ncg=5, α=0.010426)\n(step=17, χ²=32742.77, Ncg=3, α=0.029755)\n(step=18, χ²=32737.78, Ncg=3, α=0.022749)\n(step=19, χ²=32734.01, Ncg=3, α=0.018574)\n(step=20, χ²=32730.63, Ncg=3, α=0.019817)\n(step=21, χ²=32727.56, Ncg=3, α=0.016116)\n(step=22, χ²=32724.41, Ncg=3, α=0.022718)\n(step=23, χ²=32721.61, Ncg=3, α=0.014738)\n(step=24, χ²=32718.56, Ncg=3, α=0.025886)\n(step=25, χ²=32716.00, Ncg=3, α=0.013231)\n(step=26, χ²=32712.80, Ncg=3, α=0.034717)\n(step=27, χ²=32710.13, Ncg=3, α=0.010902)\n(step=28, χ²=32704.60, Ncg=3, α=0.075315)\n(step=29, χ²=32701.00, Ncg=3, α=0.008585)\n(step=30, χ²=32689.03, Ncg=4, α=0.232697)\n 40.352423 seconds (40.98 M allocations: 20.853 GiB, 9.45% gc time)"
},

{
    "location": "joint_MAP_example/#Examine-results-1",
    "page": "Joint maximum a posterior estimate",
    "title": "Examine results",
    "category": "section",
    "text": "The expected value of the final best-fit chi^2 (=-2log mathcalP) is given by the number degrees of freedom in the data, i.e. the total number of pixels in T and/or EB.χ² = -2tr[end][:lnPcur]32689.02668806845dof = getproperty((T=1, P=2, TP=3),use) * Nside^232768Here\'s how far away our final chi^2 is from this expectation, in units of sigma. We expect this should be somewhere in the range (-3,3) for about 99.7% of simulated datasets.(χ² - dof)/sqrt(2dof)-0.30848949973261597Here\'s the best-fit phi relative to the truth,plot(10^6*[ϕ ϕbf], title=[\"true\" \"best-fit\"] .* raw\" $\\phi$\");(Image: png)Here is the difference in terms of the power spectra. Note the best-fit has high-ell power suppressed, like a Wiener filter solution (in fact what we\'re doing here is akin to a non-linear Wiener filter). In the high S/N region (elllesssim1000), the difference is approixmately equal to the noise, which you can see is almost two orders of magnitude below the signal.loglog(ℓ⁴ * Cℓ[:f][:ϕϕ], \"k\")\nloglog(ℓ⁴ * get_Cℓ(ϕ))\nloglog(ℓ⁴ * get_Cℓ(ϕbf))\nloglog(ℓ⁴ * get_Cℓ(ϕbf-ϕ))\nxlim(80,3000)\nylim(5e-9,2e-6)\nlegend([\"theory\",raw\"true $\\phi$\", raw\"best-fit $\\phi$\", \"difference\"])\nxlabel(raw\"$\\ell$\")\nylabel(raw\"$\\ell^4 C_\\ell$\");(Image: png)The best-fit unlensed fields relative to truth,plot([f,fbf], title = [\"true\", \"best-fit\"] .* \" unlensed \" .* [\"E\" \"B\"]);(Image: png)The best-fit lensed field (bottom row) relative to truth (top row),plot([f̃, LenseFlow(ϕbf)*fbf], title = [\"true\", \"best-fit\"] .* \" lensed \" .* [\"E\" \"B\"]);(Image: png)"
},

{
    "location": "from_python/#",
    "page": "Using CMBLensing.jl from Python",
    "title": "Using CMBLensing.jl from Python",
    "category": "page",
    "text": ""
},

{
    "location": "from_python/#Using-CMBLensing.jl-from-Python-1",
    "page": "Using CMBLensing.jl from Python",
    "title": "Using CMBLensing.jl from Python",
    "category": "section",
    "text": "If you predominantly use Python, it\'s very easy to call CMBLensing.jl directly from your Python session. This is made possible by the PyJulia package. You can install it into your Python environment with, e.g.:$ pip install --user juliaImportant: If your Python executable is statically-linked (this is quite often the case, e.g. its the default on Ubuntu and Conda) you need one extra step. Basically, instead of running python or ipython at the command line to launch your interpreter, run python-jl  or python-jl -m IPython, respectively. These wrapper scripts set up a few extra things before dropping you into the Python/IPython interpreter that you are familiar with. For Jupyter notebooks, you can install a Jupyter kernel which uses python-jl withpython -m julia.ipykernel install --python-jlThe PyJulia docs also give instructions on two other ways to solve this issue, including a pretty easy way to install a dynamically-linked Python executable which is the most ideal solution, but slightly more work than above. "
},

{
    "location": "from_python/#Basics-of-calling-Julia-1",
    "page": "Using CMBLensing.jl from Python",
    "title": "Basics of calling Julia",
    "category": "section",
    "text": "Once PyJulia is installed, you can access any Julia package Foo from the Python package julia.Foo, and everything pretty much works transparently.import julia.Basejulia.Base.cos(1) # <--- this is Julia\'s cosine function0.5403023058681398You can also run arbitrary Julia code with the %julia cell magic (this is helpful if you want to use Julia language features or syntax which don\'t exist in Python):%load_ext julia.magicThe julia.magic extension is already loaded. To reload it, use:\n  %reload_ext julia.magicFor example, 1:10 is not valid Python syntax, but we can do:%julia 1:10range(1, 11)The cell magic lets you interpolate values from Python into the Julia expression, which can be a convenient way to pass values back and forth:x = %julia 1 + 2%julia 2 * $x6"
},

{
    "location": "from_python/#Calling-CMBLensing.jl-1",
    "page": "Using CMBLensing.jl from Python",
    "title": "Calling CMBLensing.jl",
    "category": "section",
    "text": "In Julia, using CMBLensing imports all of the CMBLensing symbols into the current namespace. In Python this is:from julia.CMBLensing import *Things then generally work the same as in Julia. For example, following this example, we load a simulated dataset:sim = load_sim_dataset(\n    θpix  = 2, \n    Nside = 256, \n    T     = julia.Base.Float32, \n    use   = \"P\"\n)Note however we did have to use julia.Base.Float32 instead of just Float32 since that is a Julia type and it\'s not exported in CMBLensing. The next step in the example is to \"unpack\" the variables in the sim objects for convenience, i.e.# julia code:\n@unpack f, ϕ, ds = simThere\'s two problems doing this in Python. First, there\'s no macro @unpack so we have to do it by hand. Second, Python does not differentiate between the characters ϕ (\\phi) and φ (\\varphi), and maps both of them back to φ (\\varphi) in Julia, which unfortunately is the wrong one for CMBLensing (which instead makes extensive use of the variable name ϕ (\\phi))To get around this, we can wrap code which needs to access  ϕ (\\phi) in %julia magic. The whole thing thus looks like:f, ϕ, ds = %julia $sim.f, $sim.ϕ, $sim.dsPlotting works the same. We first enable inline plotting:%pylab inline --no-import-all\n%config InlineBackend.rc = {\"figure.dpi\": 100} # this matches default Julia DPIPopulating the interactive namespace from numpy and matplotlibplot(ϕ);(Image: png)The call to from julia.CMBLensing import * only import CMBLensing into the Python namespace, if we want to use CMBLensing functions from %julia blocks we also need to load it there.%julia using CMBLensingLϕ = %julia LenseFlow($ϕ)In Julia you can do addition / multiplication / etc... with operators and fields. This does not work in PyJulia (yet), so you need to use %julia magic:f̃ = %julia $Lϕ * $fplot(f̃);(Image: png)"
},

{
    "location": "from_python/#Beyond-1",
    "page": "Using CMBLensing.jl from Python",
    "title": "Beyond",
    "category": "section",
    "text": "This should give you all the tools needed to run any of the other examples in CMBLensing docs from Python. As a general rule, try doing things natively from Python, and if that doesn\'t work, wrap things in %julia magic to just call the Julia code directly."
},

{
    "location": "api/#",
    "page": "API",
    "title": "API",
    "category": "page",
    "text": ""
},

{
    "location": "api/#CMBLensing.Cℓ_to_cov-Union{Tuple{P}, Tuple{T}, Tuple{Type{T},Type{P},Type{S0},InterpolatedCℓs}} where P where T",
    "page": "API",
    "title": "CMBLensing.Cℓ_to_cov",
    "category": "method",
    "text": "Convert power spectrum Cℓ to a flat sky diagonal covariance \n\n\n\n\n\n"
},

{
    "location": "api/#CMBLensing.MAP_joint-Tuple{Any}",
    "page": "API",
    "title": "CMBLensing.MAP_joint",
    "category": "method",
    "text": "MAP_joint(ds::DataSet; L=LenseFlow, Nϕ=nothing, quasi_sample=nothing, nsteps=10, Ncg=500, cgtol=1e-1, αtol=1e-5, αmax=0.5, progress=false)\n\nCompute the maximum a posteri estimate (MAP) from the joint posterior (can also do a quasi-sample). \n\nThe ds argument stores the data and other relevant objects for the dataset being considered. L gives which type of lensing operator to use. \n\nϕstart can be used to specify the starting point of the minimizer, but this is not necessary and otherwise it will start at ϕ=0. \n\nNϕ can optionally specify an estimate of the ϕ effective noise, and if provided is used to estimate a Hessian which is used in the ϕ quasi-Newton-Rhapson step. Nϕ=:qe automatically uses the quadratic estimator noise. \n\nThis function can also be used to draw quasi-samples, wherein for the f step, we draw a sample from  P(f|ϕ) instead of maximizing it (ie instead of computing Wiener filter). quasi_sample can be set to an integer seed, in which case each time in the f step we draw a same-seeded sample. If quasi_sample is instead just true, then each iteration in the algorithm draws a different sample so the solution bounces around rather than asymptoting to a maximum. \n\nThe following arguments control the maximiation procedure, and can generally be left at their defaults:\n\nnsteps - The number of iteration steps to do (each iteration updates f then updates ϕ)\nNcg - Maximum number of conjugate gradient steps during the f update\ncgtol - Conjugrate gradient tolerance (will stop at cgtol or Ncg, whichever is first)\nαtol - Tolerance for the linesearch in the ϕ quasi-Newton-Rhapson step, x′ = x - α*H⁻¹*g\nαmax - Maximum value for α in the linesearch\nprogress - Whether to print out conjugate gradient progress.\n\nReturns a tuple (f, ϕ, tr) where f is the best-fit (or quasi-sample) field, ϕ is the lensing potential, and tr contains info about the run. \n\n\n\n"
},

{
    "location": "api/#CMBLensing.MAP_marg-Tuple{Any}",
    "page": "API",
    "title": "CMBLensing.MAP_marg",
    "category": "method",
    "text": "MAP_marg( ds; kwargs...)\n\nCompute the maximum a posteri estimate (MAP) of the marginl posterior.\n\n\n\n"
},

{
    "location": "api/#CMBLensing.animate-Tuple{Union{AbstractArray{#s53,1}, AbstractArray{#s53,2}} where #s53<:Field}",
    "page": "API",
    "title": "CMBLensing.animate",
    "category": "method",
    "text": "animate(fields::Vector{\\<:Vector{\\<:Field}}; interval=50, motionblur=true, kwargs...)\n\n\n\n"
},

{
    "location": "api/#CMBLensing.bcggd-Union{Tuple{LJ}, Tuple{L}, Tuple{Any,Any,Any,Type{L}}, Tuple{Any,Any,Any,Type{L},Type{LJ}}} where LJ<:LenseOp where L<:LenseOp",
    "page": "API",
    "title": "CMBLensing.bcggd",
    "category": "method",
    "text": "Branching ConjugateGradient-GradientDescent\n\nAlgortihm:     In parallel do:     a) 2 steps of gradient descent with Ncg steps of conjugate gradient towards H⁻¹g at each iteration     b) 1 steps of gradient descent with β*Ncg steps of conjugate gradient towards H⁻¹g\n\nTake whichever is a lower lnP. If we take (b), then update Ncg = β*Ncg. \n\nβ is chosen such that (a) and (b) take roughly the same ammount of time to\ncompute (usually β≈2 but could be higher if there\'s alot of overhead for a GD step)\n\nArguments:\n\nt : which parametrization to use (i.e. t=0 for unlensed or t=1 for lensed)\nfₜϕ_start : fₜϕ to start at\nNsteps : how many iterations of the above algorithm to do\nNcg : the starting value of Ncg\nβ : scaling factor described above\nL : Lensing operator to use for gradient descent\nLJ : Lensing operator to use for the Hessian calculation\n\n\n\n\n\n"
},

{
    "location": "api/#CMBLensing.cg",
    "page": "API",
    "title": "CMBLensing.cg",
    "category": "function",
    "text": "Simple generic conjugate gradient implementation that works on Vectors, Fields, etc... \n\n\n\n\n\n"
},

{
    "location": "api/#CMBLensing.gdsteps-Union{Tuple{LJ}, Tuple{L}, Tuple{Any,Any,Any,Any,Any,Type{L}}, Tuple{Any,Any,Any,Any,Any,Type{L},Type{LJ}}} where LJ<:LenseOp where L<:LenseOp",
    "page": "API",
    "title": "CMBLensing.gdsteps",
    "category": "method",
    "text": "Do Ngd gradient descent steps, with Ncg conjugate gradient steps towards solving H⁻¹g at each iteration.\n\nArguments:\n\nt : which parametrization to use (i.e. t=0 for unlensed or t=1 for lensed)\nfₜϕ_cur : fₜϕ to start at\nNgd, Ncg : number of gradient descent and conjugate gradient steps\nL : Lensing operator to use for gradient descent\nLJ : Lensing operator to use for the Hessian calculation\n\nReturns:\n\nlnP(fₜϕ), fₜϕ, trace\n\n\n\n\n\n"
},

{
    "location": "api/#CMBLensing.lensing_wiener_filter-Union{Tuple{F}, Tuple{DataSet{F,TCn,TCf,TCf̃,TCϕ,TCn̂,TB̂,TM,TB,TD,TG,TP} where TP where TG where TD where TB where TM where TB̂ where TCn̂ where TCϕ where TCf̃ where TCf where TCn,Any}, Tuple{DataSet{F,TCn,TCf,TCf̃,TCϕ,TCn̂,TB̂,TM,TB,TD,TG,TP} where TP where TG where TD where TB where TM where TB̂ where TCn̂ where TCϕ where TCf̃ where TCf where TCn,Any,Any}} where F",
    "page": "API",
    "title": "CMBLensing.lensing_wiener_filter",
    "category": "method",
    "text": "lensing_wiener_filter(ds::DataSet, L, which=:wf)\n\nComputes either, \n\nthe Wiener filter at fixed phi, i.e. the best-fit of\n\nmathcalP(fphid)\n\na sample from mathcalP(fphid)\n\nThe data model assumed is, \n\nd = mathcalM mathcalB mathcalL  f + n\n\nNote that the noise is defined as un-debeamed and also unmasked (so it needs to be filled in outside the mask if using real data). The mask, mathcalM, can be any composition of real and/or fourier space diagonal operators.\n\nThe argument ds::DataSet stores the mask, mathcalM, the beam/instrumental transfer functions, mathcalB, as well as the various covariances which are needed.\n\nThe which parameter controls which operation to do and can be one of three things:\n\n:wf - Compute the Wiener filter\n:sample - Compute a sample from the posterior\n:fluctuation - Compute a fluctuation around the mean (i.e. a sample minus the Wiener filter)\n\n\n\n"
},

{
    "location": "api/#CMBLensing.load_sim_dataset-Tuple{}",
    "page": "API",
    "title": "CMBLensing.load_sim_dataset",
    "category": "method",
    "text": "load_sim_dataset\n\nCreate a DataSet object with some simulated data. \n\n\n\n"
},

{
    "location": "api/#CMBLensing.noisecls-Tuple{Any}",
    "page": "API",
    "title": "CMBLensing.noisecls",
    "category": "method",
    "text": "μKarcminT: temperature noise in μK-arcmin\nbeamFWHM: beam-FWHM in arcmin\n\n\n\n\n\n"
},

{
    "location": "api/#CMBLensing.norm²-Tuple{Field,LinOp}",
    "page": "API",
    "title": "CMBLensing.norm²",
    "category": "method",
    "text": "norm²(f::Field, L::LinOp)\n\nShorthand for f⋅(L\\f), i.e. the squared-norm of f w.r.t. the operator L.\n\n\n\n"
},

{
    "location": "api/#CMBLensing.pcg",
    "page": "API",
    "title": "CMBLensing.pcg",
    "category": "function",
    "text": "Preconditioned conjugate gradient. P should be symmetric and roughly √A⁻¹\n\n\n\n\n\n"
},

{
    "location": "api/#CMBLensing.pcg2",
    "page": "API",
    "title": "CMBLensing.pcg2",
    "category": "function",
    "text": "pcg2(M, A, b, x=M\\b; nsteps=length(b), tol=sqrt(eps()), progress=false, callback=nothing, hist=nothing, histmod=1)\n\nCompute x = A\\b (where A is positive definite) by conjugate gradient. M is the preconditioner and should approximate A, and M \\ x should be fast.\n\nThe solver will stop either after nsteps iterations or when dot(r,r)<tol (where r=A*x-b is the residual  at that step), whichever occurs first.\n\nInfo from the iterations of the solver can be returned if hist is specified. hist can be one or a tuple of:\n\n:i - current iteration number\n:x - current solution\n:r - current residual r=A*x-b\n:res - the norm of r\n:t - the time elapsed (in seconds) since the start of the algorithm\n\nhistmod can be used to include every N-th iteration only in hist. \n\n\n\n\n\n"
},

{
    "location": "api/#CMBLensing.pixwin-Tuple{Any,Any}",
    "page": "API",
    "title": "CMBLensing.pixwin",
    "category": "method",
    "text": "pixwin(θpix, ℓ)\n\nReturns the pixel window function for square flat-sky pixels of width θpix (in arcmin) evaluated at some ℓs. \n\nThe pixel window function is defined so that if you start with white noise at infinitely high resolution and pixelize it down a resolution θpix, its power spectrum will be given by pixwin(θpix, ℓ)^2. \n\n\n\n"
},

{
    "location": "api/#CMBLensing.resimulate-Tuple{DataSet}",
    "page": "API",
    "title": "CMBLensing.resimulate",
    "category": "method",
    "text": "resimulate(ds::DataSet; f=..., ϕ=...)\n\nResimulate the data in a given dataset, potentially at a fixed f and/or ϕ (both are resimulate if not provided)\n\n\n\n"
},

{
    "location": "api/#CMBLensing.sample_joint-Union{Tuple{DataSet{#s291,TCn,TCf,TCf̃,TCϕ,TCn̂,TB̂,TM,TB,TD,TG,TP} where TP where TG where TD where TB where TM where TB̂ where TCn̂ where TCϕ where TCf̃ where TCf where TCn where #s291<:Union{FlatS0Fourier{T,P}, FlatS0Map{T,P}, FlatS2EBFourier{T,P}, FlatS2EBMap{T,P}, FlatS2QUFourier{T,P}, FlatS2QUMap{T,P}, FieldTuple{#s57,B,S,P} where P<:PixTuple where S<:SpinTuple where B<:BasisTuple where #s57<:Tuple{Union{FlatS0Fourier{T,P}, FlatS0Map{T,P}},Union{FlatS2EBFourier{T,P}, FlatS2EBMap{T,P}, FlatS2QUFourier{T,P}, FlatS2QUMap{T,P}}}}}, Tuple{P}, Tuple{T}} where P where T",
    "page": "API",
    "title": "CMBLensing.sample_joint",
    "category": "method",
    "text": "sample_joint(ds::DataSet; kwargs...)\n\nSample from the joint PDF of P(f,ϕ,r). Runs nworkers() chains in parallel using pmap. \n\nPossible keyword arguments: \n\nnsamps_per_chain - the number of samples per chain\nnchunk - do nchunk steps in-between parallel chain communication\nnsavemaps - save maps into chain every nsavemaps steps\nnburnin_always_accept - the first nburnin_always_accept steps, always accept HMC steps independent of integration error\nnburnin_fixθ - the first nburnin_fixθ steps, fix θ at its starting point\nchains - resume an existing chain (starts a new one if nothing)\nθrange - range and density to grid sample parameters as a NamedTuple, e.g. (Aϕ=range(0.7,1.3,length=20),). \nθstart - starting values of parameters as a NamedTuple, e.g. (Aϕ=1.2,), or nothing to randomly sample from θrange\nϕstart - starting ϕ as a Field, or :quasi_sample or :best_fit\nmetadata - does nothing, but is saved into the chain file\n\n\n\n\n\n"
},

{
    "location": "api/#CMBLensing.sptlike_mask-Tuple{Any,Any}",
    "page": "API",
    "title": "CMBLensing.sptlike_mask",
    "category": "method",
    "text": "An SPT-like mask, based mostly on,\n\nFor the boundary:\n\n\"[First we] calculate the distance from the nearest masked pixel, and this distance map is smoothed using a Gaussian beam of FWHM = 15\'. This smoothing is applied to soften the corners of the mask. The distance map is then used to apodize the binary mask with a Gaussian beam of FWHM = 30\'\" - Omori et al. 2017\n\nand for point sources: \n\n\"The SPTpol deep field contains a number of bright point sources, which we mask. We identify all sources detected at > 5σ at 150 GHz from Mocanu et al. (2013), which corresponds to a flux-cut of approximately 6 mJy; all pixels within 5\' of each source are masked in both the TOD filtering and the final maps. We extend this mask to 10\' for all very bright sources detected at > 75σ. We also use a 10\' radius to mask all galaxy clusters de- tected in this field by Vanderlinde et al. (2010) using the Sunyaev-Zel’dovich effect. This masking removes ap- proximately 120 sources, cutting 5 deg² of the field. We additionally multiply the maps by a sky mask that down- weights the noisy edges of the maps.\" Story et al. 2015\n\nNote: some of the above numbers are very slightly tweaked.\n\n\n\n\n\n"
},

{
    "location": "api/#CMBLensing.symplectic_integrate-NTuple{5,Any}",
    "page": "API",
    "title": "CMBLensing.symplectic_integrate",
    "category": "method",
    "text": "symplectic_integrate(x₀, p₀, Λ, U, δUδx, N=50, ϵ=0.1, progress=false)\n\nDo a symplectic integration of the potential energy U (with gradient δUδx) starting from point x₀ with momentum p₀ and mass matrix Λ. The number of steps is N and the step size ϵ. \n\nReturns ΔH, xᵢ, pᵢ corresponding to change in Hamiltonian, and final position and momenta. If hist is specified a trace of requested variables throughout each step is also returned. \n\n\n\n\n\n"
},

{
    "location": "api/#CMBLensing.ud_grade-Union{Tuple{P}, Tuple{∂mode}, Tuple{N}, Tuple{θ}, Tuple{T}, Tuple{Union{FlatS0Fourier{T,P}, FlatS0Map{T,P}},Any}} where P<:Flat{θ,N,∂mode} where ∂mode where N where θ where T",
    "page": "API",
    "title": "CMBLensing.ud_grade",
    "category": "method",
    "text": "ud_grade(f::Field, θnew, mode=:map, deconv_pixwin=true, anti_aliasing=true)\n\nUp- or down-grades field f to new resolution θnew (only in integer steps). Two modes are available specified by the mode argument: \n\n*`:map`     : Up/downgrade by replicating/averaging pixels in map-space\n*`:fourier` : Up/downgrade by extending/truncating the Fourier grid\n\nFor :map mode, two additional options are possible. If deconv_pixwin is true, deconvolves the pixel window function from the downgraded map so the spectrum of the new and old maps are the same. If anti_aliasing is true, filters out frequencies above Nyquist prior to down-sampling. \n\n\n\n\n\n"
},

{
    "location": "api/#CMBLensing.ϕqe",
    "page": "API",
    "title": "CMBLensing.ϕqe",
    "category": "function",
    "text": "ϕqe(d, Cf, Cf̃, Cn, Cϕ=nothing)\n\nCompute quadratic estimate for ϕ given data. \n\nd - data\nCf, Cf̃ - unlensed and lensed beamed theory covariances\nCn - noise covariance (beam not deconvolved)\nCϕ - (optional) lensing potential theory covariance. if provided, the result        is Wiener filtered, otherwise the unbiased estimate is retured. \n\nReturns a tuple of (ϕqe, Nϕ) where ϕqe is the quadratic estimate and Nϕ is the N0 noise bias.\n\n\n\n\n\n"
},

{
    "location": "api/#PyPlot.plot-Tuple{Field}",
    "page": "API",
    "title": "PyPlot.plot",
    "category": "method",
    "text": "plot(f::Field; kwargs...)\nplot(fs::VecOrMat{\\<:Field}; kwarg...)\n\nPlotting fields. \n\n\n\n"
},

{
    "location": "api/#CMBLensing.Mnyq-Union{Tuple{P}, Tuple{N}, Tuple{θ}, Tuple{T}, Tuple{Type{T},Type{P},Any}} where P<:(Flat{θ,N,∂mode} where ∂mode<:CMBLensing.∂modes) where N where θ where T",
    "page": "API",
    "title": "CMBLensing.Mnyq",
    "category": "method",
    "text": "filter out the single row/column in the real FFT matrix M which corresponds to exactly the nyquist frequency \n\n\n\n\n\n"
},

{
    "location": "api/#CMBLensing.antilensing-Union{Tuple{PowerLens{N,F}}, Tuple{F}, Tuple{N}} where F where N",
    "page": "API",
    "title": "CMBLensing.antilensing",
    "category": "method",
    "text": "Create from an existing PowerLens operator one that lenses by -ϕ instead. \n\n\n\n\n\n"
},

{
    "location": "api/#CMBLensing.camb_cl_files-Tuple{Any}",
    "page": "API",
    "title": "CMBLensing.camb_cl_files",
    "category": "method",
    "text": "camb_cl_files(filename_root)\n\nLoads Cℓ\'s from some CAMB output files. filename_root should be such that $(filenameroot)scalCls.dat, etc... are the CAMB data files.\n\n\n\n"
},

{
    "location": "api/#CMBLensing.fftsyms-Union{Tuple{n}, Tuple{m}, Tuple{Val{m},Val{n}}} where n where m",
    "page": "API",
    "title": "CMBLensing.fftsyms",
    "category": "method",
    "text": "Arguments m and n refer to the sizes of an m×n matrix (call it A) that is the output of a real FFT (thus m=n÷2+1)\n\nReturns a tuple of (ireal, iimag, negks) where these are\n\n* ireal - m×n mask corrsponding to unique real entries of A\n* iimag - m×n mask corrsponding to unique imaginary entries of A\n* negks - m×n matrix of giving the index into A where the negative k-vector\n          is, s.t. A[i,j] = A[negks[i,j]]\'\n\n\n\n\n\n"
},

{
    "location": "api/#CMBLensing.fieldvalues-Tuple{Any}",
    "page": "API",
    "title": "CMBLensing.fieldvalues",
    "category": "method",
    "text": "Return the type\'s fields as a tuple\n\n\n\n\n\n"
},

{
    "location": "api/#CMBLensing.full-Union{Tuple{Fout}, Tuple{Fin}, Tuple{Type{Fin},Type{Fout},LinOp}} where Fout<:Field where Fin<:Field",
    "page": "API",
    "title": "CMBLensing.full",
    "category": "method",
    "text": "full(::Type{Fin}, ::Type{Fout}, L::LinOp; progress=true)\nfull(::Type{F}, L::LinOp; progress=true)\n\nConstruct an explicit matrix representation of the linear operator L by applying it to a set of vectors which form a complete basis. The Fin and Fout types should be fields which specify the input and output bases for the representation (or just F if L is square and we want the same input/output bases)\n\nThe name full is to be consistent with Julia\'s SparseArrays where full builds a full matrix from a sparse one.\n\n\n\n\n\n"
},

{
    "location": "api/#CMBLensing.rfft2vec-Tuple{AbstractArray{T,2} where T}",
    "page": "API",
    "title": "CMBLensing.rfft2vec",
    "category": "method",
    "text": "Convert a matrix A which is the output of a real FFT to a real vector, keeping only unqiue real/imaginary entries of A\n\n\n\n\n\n"
},

{
    "location": "api/#CMBLensing.unfold-Union{Tuple{AbstractArray{Complex{T},2}}, Tuple{T}} where T",
    "page": "API",
    "title": "CMBLensing.unfold",
    "category": "method",
    "text": "Convert an M×N matrix (with M=N÷2+1) which is the output a real FFT to a full N×N one via symmetries.\n\n\n\n\n\n"
},

{
    "location": "api/#CMBLensing.vec2rfft-Tuple{AbstractArray{#s21,1} where #s21<:Real}",
    "page": "API",
    "title": "CMBLensing.vec2rfft",
    "category": "method",
    "text": "Convert a vector produced by rfft2vec back into a complex matrix.\n\n\n\n\n\n"
},

{
    "location": "api/#CMBLensing.Σ-Union{Tuple{L}, Tuple{Any,Any}, Tuple{Any,Any,Type{L}}} where L",
    "page": "API",
    "title": "CMBLensing.Σ",
    "category": "method",
    "text": "Σ(ϕ, ds, ::Type{L}=LenseFlow) where {L}\nΣ(L::LenseOp, ds)\n\nOperator for the data covariance, Cn + PMBLCfL\'B\'M\'P\', which can applied and inverted.\n\n\n\n"
},

{
    "location": "api/#CMBLensing.δf̃_δf-Tuple{PowerLens,Any}",
    "page": "API",
    "title": "CMBLensing.δf̃_δf",
    "category": "method",
    "text": "δf̃(f,ϕ)/δf * v \n\n\n\n\n\n"
},

{
    "location": "api/#CMBLensing.δf̃_δfᴴ-Union{Tuple{N}, Tuple{PowerLens{N,F} where F<:(Field{#s57,#s56,P} where P<:Pix where #s56<:S0 where #s57),Field}} where N",
    "page": "API",
    "title": "CMBLensing.δf̃_δfᴴ",
    "category": "method",
    "text": "(δf̃(f,ϕ)/δf)ᴴ * v \n\n\n\n\n\n"
},

{
    "location": "api/#CMBLensing.δf̃_δϕ-Union{Tuple{F}, Tuple{N}, Tuple{PowerLens{N,F} where F<:(Field{#s57,#s56,P} where P<:Pix where #s56<:S0 where #s57),F,Field}} where F<:Field where N",
    "page": "API",
    "title": "CMBLensing.δf̃_δϕ",
    "category": "method",
    "text": "δf̃(f,ϕ)/δϕ * v \n\n\n\n\n\n"
},

{
    "location": "api/#CMBLensing.δf̃_δϕᴴ-Union{Tuple{F}, Tuple{N}, Tuple{PowerLens{N,F},Field,Field}} where F where N",
    "page": "API",
    "title": "CMBLensing.δf̃_δϕᴴ",
    "category": "method",
    "text": "(δf̃(f,ϕ)/δϕ)ᴴ * v \n\n\n\n\n\n"
},

{
    "location": "api/#CMBLensing.δ²f̃_δϕ²-Union{Tuple{F}, Tuple{N}, Tuple{PowerLens{N,F},Field,Field,Field}} where F where N",
    "page": "API",
    "title": "CMBLensing.δ²f̃_δϕ²",
    "category": "method",
    "text": "Compute wᴴ * δ²f̃(f,ϕ)/δϕ² * v \n\n\n\n\n\n"
},

{
    "location": "api/#CMBLensing.jrk4-Tuple{Function,Any,Any,Any,Any}",
    "page": "API",
    "title": "CMBLensing.jrk4",
    "category": "method",
    "text": "Solve for y(t₁) with 4th order Runge-Kutta assuming dy/dt = F(t,y) and y(t₀) = y₀\n\nArguments\n\nF! : a function F!(v,t,y) which sets v=F(t,y)\n\n\n\n\n\n"
},

{
    "location": "api/#API-1",
    "page": "API",
    "title": "API",
    "category": "section",
    "text": "Modules = [CMBLensing]\nOrder   = [:function, :type]"
},

]}
