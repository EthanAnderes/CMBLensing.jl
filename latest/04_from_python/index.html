<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Calling from Python · CMBLensing.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/cmblensing.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CMBLensing.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">CMBLensing.jl</a></li><li><a class="toctext" href="../01_lense_a_map/">Lensing a flat map</a></li><li><a class="toctext" href="../02_posterior/">The Lensing Posterior</a></li><li><a class="toctext" href="../03_joint_MAP_example/">Joint maximum a posteriori estimate</a></li><li class="current"><a class="toctext" href>Calling from Python</a><ul class="internal"><li><a class="toctext" href="#Basics-of-calling-Julia-1">Basics of calling Julia</a></li><li><a class="toctext" href="#Calling-CMBLensing.jl-1">Calling CMBLensing.jl</a></li><li><a class="toctext" href="#Beyond-1">Beyond</a></li></ul></li><li><a class="toctext" href="../api/">API</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Calling from Python</a></li></ul><a class="edit-page" href="https://mybinder.org/v2/gh/marius311/CMBLensing.jl/master?urlpath=lab/tree/04_from_python.ipynb"><img src="https://mybinder.org/badge_logo.svg"/></a></nav><hr/><div id="topbar"><span>Calling from Python</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Calling-from-Python-1" href="#Calling-from-Python-1">Calling from Python</a></h1><p>If you predominantly use Python, it&#39;s very easy to call CMBLensing.jl directly from your Python session. This is made possible by the <a href="https://pyjulia.readthedocs.io/en/latest/index.html">PyJulia</a> package. You can install it into your Python environment with, e.g.:</p><pre class="language-shell"><code class="language-shell">$ pip install --user julia</code></pre><p><strong>Important:</strong> If your Python executable is statically-linked (this is quite often the case, e.g. its the default on Ubuntu and Conda) you need one extra step. Basically, instead of running <code>python</code> or <code>ipython</code> at the command line to launch your interpreter, run <code>python-jl</code>  or <code>python-jl -m IPython</code>, respectively. If you use Jupyter, you&#39;ll need to edit your <code>kernel.json</code> file (you can find its location via <code>jupyter kernelspec list</code>) and change it to use <code>python-jl</code>.</p><p>The wrapper script <code>python-jl</code> does some special initializion but otherwise drops you into the Python/IPython interpreter that you are familiar with. </p><p>The <a href="https://pyjulia.readthedocs.io/en/latest/troubleshooting.html#your-python-interpreter-is-statically-linked-to-libpython">PyJulia docs</a> also give instructions on how to install a dynamically-linked Python executable which is the most ideal solution, and only slightly more work than above.</p><h2><a class="nav-anchor" id="Basics-of-calling-Julia-1" href="#Basics-of-calling-Julia-1">Basics of calling Julia</a></h2><p>Once PyJulia is installed, you can access any Julia package <code>Foo</code> from the Python package <code>julia.Foo</code>, and everything pretty much works transparently.</p><pre class="language-python"><code class="language-python">import julia.Base</code></pre><pre class="language-python"><code class="language-python">julia.Base.cos(1) # &lt;--- this is Julia&#39;s cosine function</code></pre><pre class="language-output"><code class="language-output">0.5403023058681398</code></pre><p>You can also run arbitrary Julia code with the <code>%julia</code> cell magic (this is helpful if you want to use Julia language features or syntax which don&#39;t exist in Python):</p><pre class="language-python"><code class="language-python">%load_ext julia.magic</code></pre><pre class="language-output"><code class="language-output">Initializing Julia runtime. This may take some time...</code></pre><p>For example, <code>1:10</code> is not valid Python syntax, but we can do:</p><pre class="language-python"><code class="language-python">%julia 1:10</code></pre><pre class="language-output"><code class="language-output">range(1, 11)</code></pre><p>The cell magic lets you interpolate values from Python into the Julia expression, which can be a convenient way to pass values back and forth:</p><pre class="language-python"><code class="language-python">x = %julia 1 + 2</code></pre><pre class="language-python"><code class="language-python">%julia 2 * $x</code></pre><pre class="language-output"><code class="language-output">6</code></pre><h2><a class="nav-anchor" id="Calling-CMBLensing.jl-1" href="#Calling-CMBLensing.jl-1">Calling CMBLensing.jl</a></h2><p>In Julia, <code>using CMBLensing</code> imports all of the CMBLensing symbols into the current namespace. In Python this is:</p><pre class="language-python"><code class="language-python">from julia.CMBLensing import *</code></pre><p>Things then generally work the same as in Julia. For example, following <a href="../01_lense_a_map/">this</a> example, we load a simulated dataset:</p><pre class="language-python"><code class="language-python">sim = load_sim_dataset(
    θpix  = 2, 
    Nside = 256, 
    T     = julia.Base.Float32, 
    use   = &quot;P&quot;
)</code></pre><p>Note however we did have to use <code>julia.Base.Float32</code> instead of just <code>Float32</code> since that is a Julia type and it&#39;s not exported in CMBLensing. </p><p>The next step in the example is to &quot;unpack&quot; the variables in the <code>sim</code> objects for convenience, i.e.</p><pre class="language-julia"><code class="language-julia"># julia code:
@unpack f, ϕ, ds = sim</code></pre><p>There&#39;s two problems doing this in Python. First, there&#39;s no macro <code>@unpack</code> so we have to do it by hand. Second, Python does not differentiate between the characters <code>ϕ (\phi)</code> and <code>φ (\varphi)</code>, and maps both of them back to <code>φ (\varphi)</code> in Julia, which unfortunately is the wrong one for CMBLensing (which instead makes extensive use of the variable name <code>ϕ (\phi)</code>)</p><p>To get around this, we can wrap code which needs to access  <code>ϕ (\phi)</code> in <code>%julia</code> magic. The whole thing thus looks like:</p><pre class="language-python"><code class="language-python">f, ϕ, ds = %julia $sim.f, $sim.ϕ, $sim.ds</code></pre><p>Plotting works the same. We first enable inline plotting:</p><pre class="language-python"><code class="language-python">%pylab inline --no-import-all
%config InlineBackend.rc = {&quot;figure.dpi&quot;: 100} # this matches default Julia DPI</code></pre><pre class="language-output"><code class="language-output">Populating the interactive namespace from numpy and matplotlib</code></pre><pre class="language-python"><code class="language-python">plot(ϕ);</code></pre><p><img src="../04_from_python_files/04_from_python_24_0.png" alt="png"/></p><p>The call to <code>from julia.CMBLensing import *</code> only import CMBLensing into the Python namespace, if we want to use CMBLensing functions from <code>%julia</code> blocks we also need to load it there.</p><pre class="language-python"><code class="language-python">%julia using CMBLensing</code></pre><pre class="language-python"><code class="language-python">Lϕ = %julia LenseFlow($ϕ)</code></pre><p>In Julia you can do addition / multiplication / etc... with operators and fields. This does not work in PyJulia (yet), so you need to use <code>%julia</code> magic:</p><pre class="language-python"><code class="language-python">f̃ = %julia $Lϕ * $f</code></pre><pre class="language-python"><code class="language-python">plot(f̃);</code></pre><p><img src="../04_from_python_files/04_from_python_30_0.png" alt="png"/></p><h2><a class="nav-anchor" id="Beyond-1" href="#Beyond-1">Beyond</a></h2><p>This should give you all the tools needed to run any of the other examples in CMBLensing docs from Python. As a general rule, try doing things natively from Python, and if that doesn&#39;t work, wrap things in <code>%julia</code> magic to just call the Julia code directly.</p><footer><hr/><a class="previous" href="../03_joint_MAP_example/"><span class="direction">Previous</span><span class="title">Joint maximum a posteriori estimate</span></a><a class="next" href="../api/"><span class="direction">Next</span><span class="title">API</span></a></footer></article></body></html>
