<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Field Basics · CMBLensing.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/cmblensing.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CMBLensing.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">CMBLensing.jl</a></li><li><a class="toctext" href="../01_lense_a_map/">Lensing a flat map</a></li><li><a class="toctext" href="../02_posterior/">The Lensing Posterior</a></li><li><a class="toctext" href="../03_joint_MAP_example/">Joint maximum a posteriori estimate</a></li><li><a class="toctext" href="../04_from_python/">Calling from Python</a></li><li class="current"><a class="toctext" href>Field Basics</a><ul class="internal"><li><a class="toctext" href="#Base-Fields-1">Base Fields</a></li><li><a class="toctext" href="#Diagonal-operators-1">Diagonal operators</a></li><li><a class="toctext" href="#Field-Tuples-1">Field Tuples</a></li><li><a class="toctext" href="#Field-Vectors-1">Field Vectors</a></li><li><a class="toctext" href="#Basis-Conversion-1">Basis Conversion</a></li><li><a class="toctext" href="#Properties-and-indices-1">Properties and indices</a></li></ul></li><li><a class="toctext" href="../api/">API</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Field Basics</a></li></ul><a class="edit-page" href="https://mybinder.org/v2/gh/marius311/CMBLensing.jl/master?urlpath=lab/tree/05_field_basics.ipynb"><img src="https://mybinder.org/badge_logo.svg"/></a></nav><hr/><div id="topbar"><span>Field Basics</span><a class="fa fa-bars" href="#"></a></div></header><pre class="language-julia"><code class="language-julia">using CMBLensing</code></pre><h1><a class="nav-anchor" id="Field-Basics-1" href="#Field-Basics-1">Field Basics</a></h1><h2><a class="nav-anchor" id="Base-Fields-1" href="#Base-Fields-1">Base Fields</a></h2><p>Much of CMBLensing is based on manipilating CMB &quot;fields&quot;, like temperature, Q or U polarization, or the lensing potential <span>$\phi$</span>. These types are all encompassed by the abstract type <code>Field</code>, with some concrete examples including <code>FlatMap</code> for a flat-sky map projection, or <code>FlatQUMap</code> for Q/U polarization, etc...</p><p><code>Flat</code> fields are just thing wrappers around Julia arrays, e.g.</p><pre class="language-julia"><code class="language-julia">Ix = rand(2,2)</code></pre><pre class="language-output"><code class="language-output">2×2 Array{Float64,2}:
 0.732042  0.182965
 0.998787  0.732902</code></pre><pre class="language-julia"><code class="language-julia">f = FlatMap(Ix)</code></pre><pre class="language-output"><code class="language-output">4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:
 0.7320418196232326 
 0.9987870573048432 
 0.18296504638359612
 0.7329019559062799</code></pre><p>You can see the pixels in the 2x2 map have been splayed out into a length-4 array (at least for displaying purposes). This is intentional, as even though the maps themselves are two-dimensional, it is extremely useful conceptually to think of fields as vectors (which they are, in fact, as they form an <a href="https://en.wikipedia.org/wiki/Vector_space">abstract vector space</a>). This tie to vector spaces is deeply rooted in CMBLensing, to the extent that <code>Field</code> objects are a subtype of Julia&#39;s own <code>AbstractVector</code> type, </p><pre class="language-julia"><code class="language-julia">f isa AbstractVector</code></pre><pre class="language-output"><code class="language-output">true</code></pre><p>That said, the data itself is stored as the original 2x2 matrix, and can be accessed as follows,</p><pre class="language-julia"><code class="language-julia">f.Ix</code></pre><pre class="language-output"><code class="language-output">2×2 Array{Float64,2}:
 0.732042  0.182965
 0.998787  0.732902</code></pre><p>But since <code>Fields</code> are vectors, they can be tranposed,</p><pre class="language-julia"><code class="language-julia">f&#39;</code></pre><pre class="language-output"><code class="language-output">1×4 LinearAlgebra.Adjoint{Float64,FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}}:
 0.732042  0.998787  0.182965  0.732902</code></pre><p>inner products can be computed,</p><pre class="language-julia"><code class="language-julia">f&#39; * f</code></pre><pre class="language-output"><code class="language-output">1.7803892228763662e-7</code></pre><p>and they can be added with each other as well as multiplied by scalars,</p><pre class="language-julia"><code class="language-julia">2*f+f</code></pre><pre class="language-output"><code class="language-output">4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:
 2.1961254588696977
 2.9963611719145296
 0.5488951391507884
 2.19870586771884</code></pre><h2><a class="nav-anchor" id="Diagonal-operators-1" href="#Diagonal-operators-1">Diagonal operators</a></h2><p>Vector spaces have linear operators which act on the vectors. Linear operators correpsond to matrices, thus for a map with <span>$N$</span> total pixels, a general linear operator would be an <span>$N$</span>-by-<span>$N$</span> matrix, which for even modest map sizes becomes far too large to actually store. Thus, an important class of linear operators are ones which are diagonal, since these can actually be stored. CMBLensing uses Julia&#39;s builtin <code>Diagonal</code> to represent these. <code>Diagonal(f)</code> takes a vector <code>f</code> and puts it on the diagonal of the matrix:</p><pre class="language-julia"><code class="language-julia">Diagonal(f)</code></pre><pre class="language-output"><code class="language-output">4×4 Diagonal{Float64,FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}}:
 0.732042   ⋅         ⋅         ⋅      
  ⋅        0.998787   ⋅         ⋅      
  ⋅         ⋅        0.182965   ⋅      
  ⋅         ⋅         ⋅        0.732902</code></pre><p>Multiplying this operator by the original map is then a matrix-vector product:</p><pre class="language-julia"><code class="language-julia">Diagonal(f) * f</code></pre><pre class="language-output"><code class="language-output">4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:
 0.5358852256772934 
 0.9975755858396681 
 0.03347620819815148
 0.5371452769712507</code></pre><p>Note that this is also equal to the the pointwise multiplication of <code>f</code> with itself:</p><pre class="language-julia"><code class="language-julia">f .* f</code></pre><pre class="language-output"><code class="language-output">4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:
 0.5358852256772934 
 0.9975755858396681 
 0.03347620819815148
 0.5371452769712507</code></pre><h2><a class="nav-anchor" id="Field-Tuples-1" href="#Field-Tuples-1">Field Tuples</a></h2><p>You can put <code>Fields</code> together into tuples. For example, </p><pre class="language-julia"><code class="language-julia">a = FlatMap(rand(2,2))
b = FlatMap(rand(2,2));</code></pre><pre class="language-julia"><code class="language-julia">FieldTuple(a,b)</code></pre><pre class="language-output"><code class="language-output">8-element Field2Tuple{CMBLensing.BasisTuple{Tuple{Map,Map}}, Float64}:
 0.5505235821680978  
 0.950054953812133   
 0.014057456492081677
 0.36803238748144085 
 0.006160415105918249
 0.36772974041695905 
 0.7377151845932439  
 0.3910706904663759</code></pre><p>The components can also have names:</p><pre class="language-julia"><code class="language-julia">ft = FieldTuple(a=a, b=b)</code></pre><pre class="language-output"><code class="language-output">8-element Field2Tuple{(:a, :b), CMBLensing.BasisTuple{Tuple{Map,Map}}, Float64}:
 0.5505235821680978  
 0.950054953812133   
 0.014057456492081677
 0.36803238748144085 
 0.006160415105918249
 0.36772974041695905 
 0.7377151845932439  
 0.3910706904663759</code></pre><p>which can be accessed later:</p><pre class="language-julia"><code class="language-julia">ft.a</code></pre><pre class="language-output"><code class="language-output">4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:
 0.5505235821680978  
 0.950054953812133   
 0.014057456492081677
 0.36803238748144085</code></pre><p><code>FieldTuples</code> have all of the same behavior of individual fields. Indeed, spin fields like QU or IQU are simply special <code>FieldTuples</code>:</p><pre class="language-julia"><code class="language-julia">FlatQUMap(Q=a, U=b) isa FieldTuple</code></pre><pre class="language-output"><code class="language-output">true</code></pre><h2><a class="nav-anchor" id="Field-Vectors-1" href="#Field-Vectors-1">Field Vectors</a></h2><p><em>in progress</em></p><h2><a class="nav-anchor" id="Basis-Conversion-1" href="#Basis-Conversion-1">Basis Conversion</a></h2><p>All fields are tagged as to which basis they are stored in. You can convert them to other bases by calling the basis type on them:</p><pre class="language-julia"><code class="language-julia">f</code></pre><pre class="language-output"><code class="language-output">4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:
 0.7320418196232326 
 0.9987870573048432 
 0.18296504638359612
 0.7329019559062799</code></pre><pre class="language-julia"><code class="language-julia">f′ = Fourier(f)</code></pre><pre class="language-output"><code class="language-output">4-element FlatFourier{2×2 map, 1′ pixels, fourier∂, Array{Complex{Float64}}}:
   3.564317699947486e-8 + 0.0im
 -1.0998296613404274e-8 + 0.0im
   1.097512962242427e-8 + 0.0im
   3.813755469023178e-9 + 0.0im</code></pre><p>Basis conversion is usually done automatically for you. E.g. here <code>f′</code> is automatically converted to a <code>FlatMap</code> before addition:</p><pre class="language-julia"><code class="language-julia">f + f′</code></pre><pre class="language-output"><code class="language-output">4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:
 1.4640836392464651 
 1.9975741146096864 
 0.36593009276719235
 1.4658039118125599</code></pre><p>A key feature of <code>Diagonal</code> operators is they convert the field they are acting on to the right basis before multiplication:</p><pre class="language-julia"><code class="language-julia">Diagonal(f) * f′</code></pre><pre class="language-output"><code class="language-output">4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:
 0.5358852256772935
 0.9975755858396682
 0.0334762081981515
 0.5371452769712508</code></pre><p>A <code>FlatMap</code> times a <code>FlatFourier</code> doesn&#39;t have a natural linear algebra meaning so its an error:</p><pre class="language-julia"><code class="language-julia">f * f′</code></pre><pre class="language-none"><code class="language-none">MethodError: no method matching *(::FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}, ::FlatFourier{2×2 map, 1′ pixels, fourier∂, Array{Complex{Float64}}})
Closest candidates are:
  *(::Any, ::Any, !Matched::Any, !Matched::Any...) at operators.jl:529
  *(!Matched::PyCall.PyObject, ::Any) at /home/marius/.julia/packages/PyCall/ttONZ/src/pyoperators.jl:13
  *(!Matched::FuncOp, ::Field) at /home/marius/work/baylens/src/specialops.jl:105
  ...



Stacktrace:

 [1] top-level scope at In[63]:1</code></pre><h2><a class="nav-anchor" id="Properties-and-indices-1" href="#Properties-and-indices-1">Properties and indices</a></h2><p><code>FlatMap</code> and <code>FlatFourier</code> can be indexed directly like arrays. If given 1D indices, this is the index into the vector representation:</p><pre class="language-julia"><code class="language-julia">f</code></pre><pre class="language-output"><code class="language-output">4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:
 0.7320418196232326 
 0.9987870573048432 
 0.18296504638359612
 0.7329019559062799</code></pre><pre class="language-julia"><code class="language-julia">f[1], f[2], f[3], f[4]</code></pre><pre class="language-output"><code class="language-output">(0.7320418196232326, 0.9987870573048432, 0.18296504638359612, 0.7329019559062799)</code></pre><pre class="language-julia"><code class="language-julia">f[5]</code></pre><pre class="language-none"><code class="language-none">BoundsError: attempt to access 2×2 Array{Float64,2} at index [5]



Stacktrace:

 [1] getindex at ./array.jl:728 [inlined]

 [2] getindex(::FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}, ::Int64) at /home/marius/work/baylens/src/flat_s0.jl:23

 [3] top-level scope at In[74]:1</code></pre><p>Or with a 2D index, this indexes directly into the 2D map:</p><pre class="language-julia"><code class="language-julia">f[1,1], f[2,1], f[1,2], f[2,2]</code></pre><pre class="language-output"><code class="language-output">(0.7320418196232326, 0.9987870573048432, 0.18296504638359612, 0.7329019559062799)</code></pre><p><em>Note:</em> there is no overhead to indexing <code>f</code> in this way as compared to working directly on the underlying array.</p><p>For other fields which are built on <code>FieldTuples</code>, 1D indexing will instead index the tuple indices:</p><pre class="language-julia"><code class="language-julia">ft</code></pre><pre class="language-output"><code class="language-output">8-element Field2Tuple{(:Q, :U), CMBLensing.BasisTuple{Tuple{Map,Map}}, Float64}:
 0.17774917746454766
 0.2511905982997429 
 0.6912012950726147 
 0.373539849474948  
 0.39985459058015005
 0.9001296871952931 
 0.41989219275007916
 0.5612169223732928</code></pre><pre class="language-julia"><code class="language-julia">ft[1]</code></pre><pre class="language-output"><code class="language-output">4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:
 0.17774917746454766
 0.2511905982997429 
 0.6912012950726147 
 0.373539849474948</code></pre><pre class="language-julia"><code class="language-julia">ft[2]</code></pre><pre class="language-output"><code class="language-output">4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:
 0.39985459058015005
 0.9001296871952931 
 0.41989219275007916
 0.5612169223732928</code></pre><pre class="language-julia"><code class="language-julia">ft[3]</code></pre><pre class="language-none"><code class="language-none">BoundsError: attempt to access (Q = [0.17774917746454766, 0.2511905982997429, 0.6912012950726147, 0.373539849474948], U = [0.39985459058015005, 0.9001296871952931, 0.41989219275007916, 0.5612169223732928])
  at index [3]



Stacktrace:

 [1] getindex at ./namedtuple.jl:90 [inlined]

 [2] getindex(::Field2Tuple{(:Q, :U), CMBLensing.BasisTuple{Tuple{Map,Map}}, Float64}, ::Int64) at /home/marius/work/baylens/src/field_tuples.jl:41

 [3] top-level scope at In[91]:1</code></pre><p>To get the underlying data arrays, use the object&#39;s properties:</p><pre class="language-julia"><code class="language-julia">f.Ix</code></pre><pre class="language-output"><code class="language-output">2×2 Array{Float64,2}:
 0.732042  0.182965
 0.998787  0.732902</code></pre><p>You can always find out what properties are available by typing <code>f.&lt;Tab&gt;</code>. For example, if you typed <code>ft</code> then hit <code>&lt;Tab&gt;</code> you&#39;d get:</p><pre class="language-julia"><code class="language-julia">ft |&gt; propertynames</code></pre><pre class="language-output"><code class="language-output">(:fs, :Q, :U, :Qx, :Ux)</code></pre><p>For a <code>FieldTuple</code> like the <code>FlatQUMap</code> object, <code>ft</code>, you can get each individual Q or U field:</p><pre class="language-julia"><code class="language-julia">ft.Q</code></pre><pre class="language-output"><code class="language-output">4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:
 0.6922927799412399
 0.6961360514468293
 0.8130790577325409
 0.8044087072888599</code></pre><p>Or <code>ft.Qx</code> which is shorthand for <code>ft.Q.Ix</code>:</p><pre class="language-julia"><code class="language-julia">ft.Q.Ix === ft.Qx</code></pre><pre class="language-output"><code class="language-output">true</code></pre><p>If you convert <code>f</code> to Fourier space, it would have the <code>Il</code> property to get the Fourier coefficients:</p><pre class="language-julia"><code class="language-julia">Fourier(f).Il</code></pre><pre class="language-output"><code class="language-output">2×2 Array{Complex{Float64},2}:
  3.56432e-8+0.0im  1.09751e-8+0.0im
 -1.09983e-8+0.0im  3.81376e-9+0.0im</code></pre><p>For convenience, you can also use the <code>[:...]</code> syntax which does the conversion automatically:</p><pre class="language-julia"><code class="language-julia">f[:Il]</code></pre><pre class="language-output"><code class="language-output">2×2 Array{Complex{Float64},2}:
  3.56432e-8+0.0im  1.09751e-8+0.0im
 -1.09983e-8+0.0im  3.81376e-9+0.0im</code></pre><p>This works between any bases. For example. <code>ft</code> is originally <code>QUMap</code> but we can convert to <code>EBFourier</code> and get the <code>El</code> coefficients:</p><pre class="language-julia"><code class="language-julia">ft[:El]</code></pre><pre class="language-output"><code class="language-output">2×2 Array{Complex{Float64},2}:
 -4.04808e-8-0.0im  3.08475e-9+0.0im
 6.50065e-11+0.0im    6.633e-9+0.0im</code></pre><p>The general rule for these two ways of accessing the underlying data is:</p><ul><li><strong>Properties</strong> (i.e. <code>f.Ix</code>) are type-stable and get you the underlying data arrays, even recursively from <code>FieldTuples</code>. If these arrays are modified, they affect the original field.</li><li><strong>Indices</strong> (i.e. <code>f[:Ix]</code>) are not type-stable, and may not be one of the underlying data arrays (because a basis conversion may have been performed). They should be used for getting (not setting) data, and in non-performance-critical code. </li></ul><footer><hr/><a class="previous" href="../04_from_python/"><span class="direction">Previous</span><span class="title">Calling from Python</span></a><a class="next" href="../api/"><span class="direction">Next</span><span class="title">API</span></a></footer></article></body></html>
