var documenterSearchIndex = {"docs":
[{"location":"01_lense_a_map/#Lensing-a-flat-map-1","page":"Lensing a flat map","title":"Lensing a flat map","text":"","category":"section"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"using CMBLensing","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"First we load a simulated unlensed field, f, and lensing potential, phi,","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"@unpack f,ϕ = load_sim_dataset(\n    θpix  = 2,       # size of the pixels in arcmin\n    Nside = 256,     # number of pixels per side in the map\n    T     = Float32, # Float32 or Float64 (former is ~twice as fast)\n    use   = :I       # :I for Intensity, :P for polarization, or :IP for both\n);","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"We can lense the map with LenseFlow,","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"f̃ = LenseFlow(ϕ) * f;","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"And flip between lensed and unlensed maps,","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"animate([f,f̃], interval=500)","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"<video width=\"560\" height=\"400\" controls autoplay loop>\n  <source type=\"video/mp4\" src=\"data:video/mp4;base64,AAAAHGZ0eXBNNFYgAAACAGlzb21pc28yYXZjMQAAAAhmcmVlAACyB21kYXQAAAKuBgX//6rcRem9\n5tlIt5Ys2CDZI+7veDI2NCAtIGNvcmUgMTU1IHIyOTE3IDBhODRkOTggLSBILjI2NC9NUEVHLTQg\nQVZDIGNvZGVjIC0gQ29weWxlZnQgMjAwMy0yMDE4IC0gaHR0cDovL3d3dy52aWRlb2xhbi5vcmcv\neDI2NC5odG1sIC0gb3B0aW9uczogY2FiYWM9MSByZWY9MyBkZWJsb2NrPTE6MDowIGFuYWx5c2U9\nMHgzOjB4MTEzIG1lPWhleCBzdWJtZT03IHBzeT0xIHBzeV9yZD0xLjAwOjAuMDAgbWl4ZWRfcmVm\nPTEgbWVfcmFuZ2U9MTYgY2hyb21hX21lPTEgdHJlbGxpcz0xIDh4OGRjdD0xIGNxbT0wIGRlYWR6\nb25lPTIxLDExIGZhc3RfcHNraXA9MSBjaHJvbWFfcXBfb2Zmc2V0PS0yIHRocmVhZHM9MTIgbG9v\na2FoZWFkX3RocmVhZHM9MiBzbGljZWRfdGhyZWFkcz0wIG5yPTAgZGVjaW1hdGU9MSBpbnRlcmxh\nY2VkPTAgYmx1cmF5X2NvbXBhdD0wIGNvbnN0cmFpbmVkX2ludHJhPTAgYmZyYW1lcz0zIGJfcHly\nYW1pZD0yIGJfYWRhcHQ9MSBiX2JpYXM9MCBkaXJlY3Q9MSB3ZWlnaHRiPTEgb3Blbl9nb3A9MCB3\nZWlnaHRwPTIga2V5aW50PTI1MCBrZXlpbnRfbWluPTIgc2NlbmVjdXQ9NDAgaW50cmFfcmVmcmVz\naD0wIHJjX2xvb2thaGVhZD00MCByYz1jcmYgbWJ0cmVlPTEgY3JmPTIzLjAgcWNvbXA9MC42MCBx\ncG1pbj0wIHFwbWF4PTY5IHFwc3RlcD00IGlwX3JhdGlvPTEuNDAgYXE9MToxLjAwAIAAAJSaZYiE\nABT//vfHT8Cm6Plmy51FPSEwitj6SCpV/4SvUIgDlCXPdISb2ioRzyH98XQfynaCDh8So5Leh8Zc\ng0Kx1AN2PTeTZ2+EsEV1L7u6Z8H7KHPP+uJFSIfFD/mMBvOJGTgDMyOuffW4U9hwjLr4ok1BW1ff\nQ+PoXdy7ZPoxfyU0ICpLwrWqiF0rB7mXqGs7IEZeI2rtazbbEwJQ0m2ApjJu+e6BRuK2nOyMao1T\n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\nAAEAAAAATGF2ZjU4LjIwLjEwMA==\n\">\n  Your browser does not support the video tag.\n</video>","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"The difference between lensed and unlensed,","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"plot(f-f̃);","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"(Image: png)","category":"page"},{"location":"01_lense_a_map/#Loading-your-own-data-1","page":"Lensing a flat map","title":"Loading your own data","text":"","category":"section"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"CMBLensing flat-sky Field objects like f or ϕ  are just thin wrappers around arrays. You can get the underlying data arrays for I(mathbfx), Q(mathbfx), and U(mathbfx) with f[:Ix], f[:Qx], and f[:Ux] respectively, or the Fourier coefficients, I(mathbfl), Q(mathbfl), and U(mathbfl) with f[:Il], f[:Ql], and f[:Ul],","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"mapdata = f[:Ix]","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"256×256 Array{Float32,2}:\n  64.2791   55.2669   58.0685   66.9672  …   42.6668   50.974    63.7438\n  58.8753   64.3192   69.2355   67.9249      47.2811   43.9675   50.903 \n  47.9415   62.8338   67.1773   57.8098      65.6617   46.3922   38.789 \n  40.8003   57.5675   61.4263   50.4418      84.1808   52.8753   33.9909\n  33.4472   52.4513   59.2947   52.7618      87.2596   49.8912   27.2819\n  35.319    54.0066   62.3652   58.3315  …   93.3228   53.7185   30.3909\n  48.9978   58.9065   64.0997   59.6179     112.934    77.6224   52.8075\n  57.4568   56.8943   60.5485   60.3225     129.566   101.24     73.6986\n  55.8345   51.0549   61.0484   75.1528     137.261   110.493    79.123 \n  60.5948   53.9406   68.8473  100.948      141.285   116.737    84.4385\n  80.784    74.1863   88.2169  129.771   …  141.638   123.761    98.0308\n 103.625   101.867   117.409   158.377      141.797   130.164   113.088 \n 120.499   122.144   137.715   173.097      140.859   138.814   128.592 \n   ⋮                                     ⋱                        ⋮     \n 154.675   147.622   133.835   111.795      191.507   178.946   163.881 \n 154.32    143.727   122.432    96.2404  …  176.458   165.803   158.65  \n 168.839   154.14    121.612    87.1151     168.691   165.536   167.228 \n 181.957   167.06    125.627    83.7806     158.974   164.15    173.809 \n 176.441   164.543   121.979    80.7129     143.07    149.476   163.569 \n 142.509   133.283   102.802    75.5037     129.677   131.688   137.083 \n  95.9846   88.799    77.9394   69.6128  …  118.322   116.249   105.961 \n  58.798    54.7852   58.6457   61.8471      99.4583   94.8563   76.6664\n  41.414    40.2528   46.6454   50.9392      68.9178   67.7693   54.6573\n  37.9514   35.3816   39.7851   44.696       40.2756   46.6831   44.8432\n  41.2062   32.5725   36.0259   46.8317      32.9084   43.0516   47.6964\n  53.6523   39.907    41.9986   55.917   …   39.3381   50.7672   59.5893","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"If you have your own map data in an array you'd like to load into a CMBLensing Field object, you can construct it as follows:","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"FlatMap(mapdata, θpix=3)","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"65536-element FlatMap{256×256 map, 3′ pixels, fourier∂, Array{Float32}}:\n  64.2791  \n  58.875256\n  47.94148 \n  40.80034 \n  33.447178\n  35.31899 \n  48.99784 \n  57.45679 \n  55.83453 \n  60.594822\n  80.78398 \n 103.624504\n 120.49947 \n   ⋮       \n 163.88123 \n 158.65012 \n 167.22845 \n 173.80888 \n 163.56894 \n 137.0829  \n 105.96126 \n  76.66639 \n  54.657322\n  44.843227\n  47.696434\n  59.58931","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"For more info on Field objects, see Field Basics.","category":"page"},{"location":"01_lense_a_map/#Inverse-lensing-1","page":"Lensing a flat map","title":"Inverse lensing","text":"","category":"section"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"You can inverse lense a map with the \\ operator (which does A \\ b ≡ inv(A) * b):","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"LenseFlow(ϕ) \\ f;","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"Note that this is true inverse lensing, rather than lensing by the negative deflection (which is often called \"anti-lensing\"). This means that lensing then inverse lensing a map should get us back the original map. Lets check that this is the case:","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"Ns = [7 10 20]\nplot([f - (LenseFlow(ϕ,N) \\ (LenseFlow(ϕ,N) * f)) for N in Ns],\n    title=[\"ODE steps = $N\" for N in Ns]);","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"(Image: png)","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"A cool feature of LenseFlow is that inverse lensing is trivially done by running the LenseFlow ODE in reverse. Note that as we crank up the number of ODE steps above, we recover the original map to higher and higher precision.","category":"page"},{"location":"01_lense_a_map/#Other-lensing-algorithms-1","page":"Lensing a flat map","title":"Other lensing algorithms","text":"","category":"section"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"We can also lense via:","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"PowerLens: the standard Taylor series expansion to any order:","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":" f(x+nabla x) approx f(x) + (nabla f)(nabla phi) + frac12 (nabla nabla f) (nabla phi)^2 +  ","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"TayLens (Næss&Louis 2013): like PowerLens, but first a nearest-pixel permute step, then a Taylor expansion around the now-smaller residual displacement","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"plot([(PowerLens(ϕ,2)*f - f̃) (Taylens(ϕ,2)*f - f̃)], \n    title=[\"PowerLens - LenseFlow\" \"TayLens - LenseFlow\"]);","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"(Image: png)","category":"page"},{"location":"01_lense_a_map/#Benchmarking-1","page":"Lensing a flat map","title":"Benchmarking","text":"","category":"section"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"LenseFlow is highly optimized code since it appears on the inner-most loop of our analysis algorithms. To benchmark LenseFlow, note that there is first a precomputation step, which caches some data in preparation for applying it to a field of a given type. This was done automatically when evaluating LenseFlow(ϕ) * f but we can benchmark it separately since in many cases this only needs to be done once for a given phi, e.g. when Wiener filtering at fixed phi,","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"using BenchmarkTools","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"@benchmark cache(LenseFlow(ϕ),f)","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"BenchmarkTools.Trial: \n  memory estimate:  91.09 MiB\n  allocs estimate:  1749\n  --------------\n  minimum time:     27.816 ms (30.10% GC)\n  median time:      126.418 ms (84.52% GC)\n  mean time:        96.728 ms (76.24% GC)\n  maximum time:     176.518 ms (81.41% GC)\n  --------------\n  samples:          53\n  evals/sample:     1","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"Once cached, it's very fast and memory non-intensive to repeatedly apply the operator:","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"@benchmark Lϕ * f setup=(Lϕ=cache(LenseFlow(ϕ),f))","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"BenchmarkTools.Trial: \n  memory estimate:  2.01 MiB\n  allocs estimate:  279\n  --------------\n  minimum time:     15.270 ms (0.00% GC)\n  median time:      16.037 ms (0.00% GC)\n  mean time:        21.644 ms (25.05% GC)\n  maximum time:     143.934 ms (86.79% GC)\n  --------------\n  samples:          44\n  evals/sample:     1","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat map","title":"Lensing a flat map","text":"","category":"page"},{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Modules = [CMBLensing]\nOrder   = [:function, :type]","category":"page"},{"location":"api/#CMBLensing.MAP_joint-Tuple{Any}","page":"API","title":"CMBLensing.MAP_joint","text":"MAP_joint(ds::DataSet; L=LenseFlow, Nϕ=nothing, quasi_sample=nothing, nsteps=10, Ncg=500, cgtol=1e-1, αtol=1e-5, αmax=0.5, progress=false)\n\nCompute the maximum a posteri estimate (MAP) from the joint posterior (can also do a quasi-sample). \n\nThe ds argument stores the data and other relevant objects for the dataset being considered. L gives which type of lensing operator to use. \n\nϕstart can be used to specify the starting point of the minimizer, but this is not necessary and otherwise it will start at ϕ=0. \n\nNϕ can optionally specify an estimate of the ϕ effective noise, and if provided is used to estimate a Hessian which is used in the ϕ quasi-Newton-Rhapson step. Nϕ=:qe automatically uses the quadratic estimator noise. \n\nThis function can also be used to draw quasi-samples, wherein for the f step, we draw a sample from  P(f|ϕ) instead of maximizing it (ie instead of computing Wiener filter). quasi_sample can be set to an integer seed, in which case each time in the f step we draw a same-seeded sample. If quasi_sample is instead just true, then each iteration in the algorithm draws a different sample so the solution bounces around rather than asymptoting to a maximum. \n\nThe following arguments control the maximiation procedure, and can generally be left at their defaults:\n\nnsteps - The number of iteration steps to do (each iteration updates f then updates ϕ)\nNcg - Maximum number of conjugate gradient steps during the f update\ncgtol - Conjugrate gradient tolerance (will stop at cgtol or Ncg, whichever is first)\nαtol - Tolerance for the linesearch in the ϕ quasi-Newton-Rhapson step, x′ = x - α*H⁻¹*g\nαmax - Maximum value for α in the linesearch\nprogress - Whether to print out conjugate gradient progress.\n\nReturns a tuple (f, ϕ, tr) where f is the best-fit (or quasi-sample) field, ϕ is the lensing potential, and tr contains info about the run. \n\n\n\n","category":"method"},{"location":"api/#CMBLensing.MAP_marg-Tuple{Any}","page":"API","title":"CMBLensing.MAP_marg","text":"MAP_marg( ds; kwargs...)\n\nCompute the maximum a posteri estimate (MAP) of the marginl posterior.\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.animate-Tuple{Union{AbstractArray{#s104,1}, AbstractArray{#s104,2}} where #s104<:Field}","page":"API","title":"CMBLensing.animate","text":"animate(fields::Vector{\\<:Vector{\\<:Field}}; interval=50, motionblur=false, kwargs...)\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.argmaxf_lnP-Tuple{Field,Any}","page":"API","title":"CMBLensing.argmaxf_lnP","text":"argmaxf_lnP(ϕ,                ds::DataSet; kwargs...)\nargmaxf_lnP(ϕ, θ::NamedTuple, ds::DataSet; kwargs...)\nargmaxf_lnP(Lϕ::LenseOp,      ds::DataSet; kwargs...)\n\nComputes either the Wiener filter at fixed phi, or a sample from this slice along the posterior.\n\nKeyword arguments: \n\nwhich : :wf, :sample, or fluctuation to compute 1) the Wiener filter, i.e. the best-fit of mathcalP(fphid), 2) a sample from mathcalP(fphid), or 3) a sample minus the Wiener filter, i.e. the fluctuation on top of the mean.\nguess : starting guess for f for the conjugate gradient solver\nkwargs : all other arguments are passed to conjugate_gradient\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.gradhess-Tuple{Any}","page":"API","title":"CMBLensing.gradhess","text":"gradhess(f)\n\nCompute the gradient gⁱ = ∇ⁱf, and the hessian, Hⁱⱼ = ∇ⱼ∇ⁱf\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.lnP","page":"API","title":"CMBLensing.lnP","text":"lnP(t, fₜ, ϕₜ,                ds::DataSet, Lϕ=nothing)\nlnP(t, fₜ, ϕₜ, θ::NamedTuple, ds::DataSet, Lϕ=nothing)\n\nCompute the log posterior probability in the joint parameterization as a function of the field, f_t, the lensing potential, phi_t, and possibly some cosmological parameters, theta. The subscript t can refer to either a \"time\", e.g. passing t=0 corresponds to the unlensed parametrization and t=1 to the lensed one, or can be :mix correpsonding to the mixed parametrization. In all cases, the arguments fₜ and ϕₜ should then be f and phi in that particular parametrization.\n\nIf any parameters theta are passed, we also include the three determinant terms to properly normalize the posterior.\n\nThe argument ds should be a DataSet and stores the masks, data, etc... needed to construct the posterior. If Lϕ is provided, it will be used as memory to recache the lensing operator at the specified ϕ.\n\n\n\n","category":"function"},{"location":"api/#CMBLensing.load_sim_dataset-Tuple{}","page":"API","title":"CMBLensing.load_sim_dataset","text":"load_sim_dataset\n\nCreate a DataSet object with some simulated data. E.g.\n\n@unpack f,ϕ,ds = load_sim_dataset(;\n    θpix  = 2,\n    Nside = 128,\n    use   = :I,\n    T     = Float32\n);\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.noiseCℓs-Tuple{}","page":"API","title":"CMBLensing.noiseCℓs","text":"noiseCℓs(;μKarcminT, beamFWHM=0, ℓmax=8000, ℓknee=100, αknee=3)\n\nCompute the (:TT,:EE,:BB,:TE) noise power spectra given white noise + 1/f. Polarization noise is scaled by sqrt2 relative to μKarcminT. beamFWHM is in arcmin.\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.pixwin-Tuple{Any,Any}","page":"API","title":"CMBLensing.pixwin","text":"pixwin(θpix, ℓ)\n\nReturns the pixel window function for square flat-sky pixels of width θpix (in arcmin) evaluated at some ℓs. This is the scaling of k-modes, the scaling of the power spectrum will be pixwin^2. \n\n\n\n","category":"method"},{"location":"api/#CMBLensing.quadratic_estimate-Union{Tuple{F2}, Tuple{F1}, Tuple{Tuple{DataSet{F1,TCn,TCf,TCf̃,TCϕ,TCn̂,TM,TM̂,TB,TB̂,TD,TG,TP,TL} where TL where TP where TG where TD where TB̂ where TB where TM̂ where TM where TCn̂ where TCϕ where TCf̃ where TCf where TCn,DataSet{F2,TCn,TCf,TCf̃,TCϕ,TCn̂,TM,TM̂,TB,TB̂,TD,TG,TP,TL} where TL where TP where TG where TD where TB̂ where TB where TM̂ where TM where TCn̂ where TCϕ where TCf̃ where TCf where TCn},Any}} where F2 where F1","page":"API","title":"CMBLensing.quadratic_estimate","text":"quadratic_estimate(ds::DataSet, which; wiener_filtered=true)\nquadratic_estimate((ds1::DataSet,ds2::DataSet), which; wiener_filtered=true)\n\nCompute quadratic estimate of ϕ given data.\n\nThe ds or (ds1,ds2) tuple contain the DataSet object(s) which houses the data and covariances used in the estimate. Note that only the Fourier-diagonal approximations for the beam, mask, and noise,, i.e. ds.B̂, ds.M̂, and ds.Cn̂, are accounted for. To account full operators (if they are not actually Fourier-diagonal), you should compute the impact using Monte Carlo.\n\nIf a tuple is passed in, the result will come from correlating the data from ds1 with that from ds2, which can be useful for debugging / isolating various noise terms. \n\nAn optional keyword argument AL can be passed in in case the QE normalization was already computed, in which case it won't be recomputed during the calculation.\n\nReturns a NamedTuple (ϕqe, AL, Nϕ) where ϕqe is the (possibly Wiener filtered, depending on wiener_filtered option) quadratic estimate, AL is the normalization (which is already applied to ϕqe, it does not need to be applied again), and Nϕ is the analytic N0 noise bias (Nϕ==AL if using unlensed weights, currently only Nϕ==AL is always returned, no matter the weights)\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.resimulate-Tuple{DataSet}","page":"API","title":"CMBLensing.resimulate","text":"resimulate(ds::DataSet; f=..., ϕ=...)\n\nResimulate the data in a given dataset, potentially at a fixed f and/or ϕ (both are resimulated if not provided)\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.sample_joint-Union{Tuple{DataSet{#s159,TCn,TCf,TCf̃,TCϕ,TCn̂,TM,TM̂,TB,TB̂,TD,TG,TP,TL} where TL where TP where TG where TD where TB̂ where TB where TM̂ where TM where TCn̂ where TCϕ where TCf̃ where TCf where TCn where #s159<:(Union{FieldTuple{CMBLensing.BasisTuple{Tuple{Fourier,EBFourier}},NamedTuple{(:I, :P),Tuple{FlatFourier{T,P,M},FieldTuple{EBFourier,NamedTuple{(:E, :B),Tuple{FlatFourier{T,P,M},FlatFourier{T,P,M}}},Complex{P}}}},Complex{P}}, FieldTuple{CMBLensing.BasisTuple{Tuple{Fourier,QUFourier}},NamedTuple{(:I, :P),Tuple{FlatFourier{T,P,M},FieldTuple{QUFourier,NamedTuple{(:Q, :U),Tuple{FlatFourier{T,P,M},FlatFourier{T,P,M}}},Complex{P}}}},Complex{P}}, FieldTuple{CMBLensing.BasisTuple{Tuple{Map,EBMap}},NamedTuple{(:I, :P),Tuple{FlatMap{T,P,M},FieldTuple{EBMap,NamedTuple{(:E, :B),Tuple{FlatMap{T,P,M},FlatMap{T,P,M}}},P}}},P}, FieldTuple{CMBLensing.BasisTuple{Tuple{Map,QUMap}},NamedTuple{(:I, :P),Tuple{FlatMap{T,P,M},FieldTuple{QUMap,NamedTuple{(:Q, :U),Tuple{FlatMap{T,P,M},FlatMap{T,P,M}}},P}}},P}, FieldTuple{EBFourier,NamedTuple{(:E, :B),Tuple{FlatFourier{T,P,M},FlatFourier{T,P,M}}},Complex{P}}, FieldTuple{EBMap,NamedTuple{(:E, :B),Tuple{FlatMap{T,P,M},FlatMap{T,P,M}}},P}, FieldTuple{QUFourier,NamedTuple{(:Q, :U),Tuple{FlatFourier{T,P,M},FlatFourier{T,P,M}}},Complex{P}}, FieldTuple{QUMap,NamedTuple{(:Q, :U),Tuple{FlatMap{T,P,M},FlatMap{T,P,M}}},P}, FlatFourier{T,P,M}, FlatMap{T,P,M}} where M)}, Tuple{P}, Tuple{T}} where P where T","page":"API","title":"CMBLensing.sample_joint","text":"sample_joint(ds::DataSet; kwargs...)\n\nSample from the joint PDF of P(f,ϕ,θ). Runs nworkers() chains in parallel using pmap. \n\nPossible keyword arguments: \n\nnsamps_per_chain - the number of samples per chain\nnchunk - do nchunk steps in-between parallel chain communication\nnsavemaps - save maps into chain every nsavemaps steps\nnburnin_always_accept - the first nburnin_always_accept steps, always accept HMC steps independent of integration error\nnburnin_fixθ - the first nburnin_fixθ steps, fix θ at its starting point\nchains - resume an existing chain (starts a new one if nothing)\nθrange - range and density to grid sample parameters as a NamedTuple, e.g. (Aϕ=range(0.7,1.3,length=20),). \nθstart - starting values of parameters as a NamedTuple, e.g. (Aϕ=1.2,), or nothing to randomly sample from θrange\nϕstart - starting ϕ as a Field, or :quasi_sample or :best_fit\nmetadata - does nothing, but is saved into the chain file\nnhmc - the number of HMC passes per ϕ Gibbs step (default: 1)\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.symplectic_integrate-Union{Tuple{T}, Tuple{AbstractArray{T,1},Any,Any,Any,Any}} where T","page":"API","title":"CMBLensing.symplectic_integrate","text":"symplectic_integrate(x₀, p₀, Λ, U, δUδx, N=50, ϵ=0.1, progress=false)\n\nDo a symplectic integration of the potential energy U (with gradient δUδx) starting from point x₀ with momentum p₀ and mass matrix Λ. The number of steps is N and the step size ϵ. \n\nReturns ΔH, xᵢ, pᵢ corresponding to change in Hamiltonian, and final position and momenta. If hist is specified a trace of requested variables throughout each step is also returned. \n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.ud_grade-Union{Tuple{P}, Tuple{∂mode}, Tuple{N}, Tuple{θ}, Tuple{T}, Tuple{Union{FlatFourier{P,T,M}, FlatMap{P,T,M}} where M,Any}} where P<:Flat{N,θ,∂mode} where ∂mode where N where θ where T","page":"API","title":"CMBLensing.ud_grade","text":"ud_grade(f::Field, θnew, mode=:map, deconv_pixwin=true, anti_aliasing=true)\n\nUp- or down-grades field f to new resolution θnew (only in integer steps). Two modes are available specified by the mode argument: \n\n*`:map`     : Up/downgrade by replicating/averaging pixels in map-space\n*`:fourier` : Up/downgrade by extending/truncating the Fourier grid\n\nFor :map mode, two additional options are possible. If deconv_pixwin is true, deconvolves the pixel window function from the downgraded map so the spectrum of the new and old maps are the same. If anti_aliasing is true, filters out frequencies above Nyquist prior to down-sampling. \n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.δlnP_δfϕₜ","page":"API","title":"CMBLensing.δlnP_δfϕₜ","text":"δlnP_δfϕₜ(t, fₜ, ϕ,                ds, Lϕ=nothing)\nδlnP_δfϕₜ(t, fₜ, ϕ, θ::NamedTuple, ds, Lϕ=nothing)\n\nCompute a gradient of the log posterior probability. See lnP for definition of arguments of this function. \n\nThe return type is a FieldTuple corresponding to the (f_tphi) derivative.\n\n\n\n","category":"function"},{"location":"api/#PyPlot.plot-Tuple{Field}","page":"API","title":"PyPlot.plot","text":"plot(f::Field; kwargs...)\nplot(fs::VecOrMat{\\<:Field}; kwarg...)\n\nPlotting fields. \n\n\n\n","category":"method"},{"location":"api/#CMBLensing.FlatEBFourier","page":"API","title":"CMBLensing.FlatEBFourier","text":"# main constructor:\nFlatEBFourier(El::AbstractMatrix, Bl::AbstractMatrix[, θpix={resolution in arcmin}, ∂mode={fourier∂ or map∂})\n\n# more low-level:\nFlatEBFourier{P}(El::AbstractMatrix, Bl::AbstractMatrix) # specify pixelization P explicilty\nFlatEBFourier{P,T}(El::AbstractMatrix, Bl::AbstractMatrix) # additionally, convert elements to type Complex{T}\nFlatEBFourier{P,T,M<:AbstractMatrix{Complex{T}}}(El::M, Bl::M) # specify everything explicilty\n\nConstruct a FlatEBFourier object. The top form of the constructor is most convenient for interactive work, while the others may be more useful for low-level code.\n\n\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.FlatEBMap","page":"API","title":"CMBLensing.FlatEBMap","text":"# main constructor:\nFlatEBMap(Ex::AbstractMatrix, Bx::AbstractMatrix[, θpix={resolution in arcmin}, ∂mode={fourier∂ or map∂})\n\n# more low-level:\nFlatEBMap{P}(Ex::AbstractMatrix, Bx::AbstractMatrix) # specify pixelization P explicilty\nFlatEBMap{P,T}(Ex::AbstractMatrix, Bx::AbstractMatrix) # additionally, convert elements to type T\nFlatEBMap{P,T,M<:AbstractMatrix{T}}(Ex::M, Bx::M) # specify everything explicilty\n\nConstruct a FlatEBMap object. The top form of the constructor is most convenient for interactive work, while the others may be more useful for low-level code.\n\n\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.FlatFourier","page":"API","title":"CMBLensing.FlatFourier","text":"# main constructor:\nFlatFourier(Il::AbstractMatrix[, θpix={resolution in arcmin}, ∂mode={fourier∂ or map∂})\n\n# more low-level:\nFlatFourier{P}(Il::AbstractMatrix) # specify pixelization P explicilty\nFlatFourier{P,T}(Il::AbstractMatrix) # additionally, convert elements to type Complex{T}\nFlatFourier{P,T,M<:AbstractMatrix{Complex{T}}}(Il::M) # specify everything explicilty\n\nConstruct a FlatFourier object. The top form of the constructor is most convenient for interactive work, while the others may be more useful for low-level code.\n\n\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.FlatIEBFourier","page":"API","title":"CMBLensing.FlatIEBFourier","text":"# main constructor:\nFlatIEBFourier(Il::AbstractMatrix, El::AbstractMatrix, Bl::AbstractMatrix[, θpix={resolution in arcmin}, ∂mode={fourier∂ or map∂})\n\n# more low-level:\nFlatIEBFourier{P}(Il::AbstractMatrix, El::AbstractMatrix, Bl::AbstractMatrix) # specify pixelization P explicilty\nFlatIEBFourier{P,T}(Il::AbstractMatrix, El::AbstractMatrix, Bl::AbstractMatrix) # additionally, convert elements to type Complex{T}\nFlatIEBFourier{P,T,M<:AbstractMatrix{Complex{T}}}(Il::M, El::M, Bl::M) # specify everything explicilty\n\nConstruct a FlatIEBFourier object. The top form of the constructor is most convenient for interactive work, while the others may be more useful for low-level code.\n\n\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.FlatIEBMap","page":"API","title":"CMBLensing.FlatIEBMap","text":"# main constructor:\nFlatIEBMap(Ix::AbstractMatrix, Ex::AbstractMatrix, Bx::AbstractMatrix[, θpix={resolution in arcmin}, ∂mode={fourier∂ or map∂})\n\n# more low-level:\nFlatIEBMap{P}(Ix::AbstractMatrix, Ex::AbstractMatrix, Bx::AbstractMatrix) # specify pixelization P explicilty\nFlatIEBMap{P,T}(Ix::AbstractMatrix, Ex::AbstractMatrix, Bx::AbstractMatrix) # additionally, convert elements to type T\nFlatIEBMap{P,T,M<:AbstractMatrix{T}}(Ix::M, Ex::M, Bx::M) # specify everything explicilty\n\nConstruct a FlatIEBMap object. The top form of the constructor is most convenient for interactive work, while the others may be more useful for low-level code.\n\n\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.FlatIQUFourier","page":"API","title":"CMBLensing.FlatIQUFourier","text":"# main constructor:\nFlatIQUFourier(Il::AbstractMatrix, Ql::AbstractMatrix, Ul::AbstractMatrix[, θpix={resolution in arcmin}, ∂mode={fourier∂ or map∂})\n\n# more low-level:\nFlatIQUFourier{P}(Il::AbstractMatrix, Ql::AbstractMatrix, Ul::AbstractMatrix) # specify pixelization P explicilty\nFlatIQUFourier{P,T}(Il::AbstractMatrix, Ql::AbstractMatrix, Ul::AbstractMatrix) # additionally, convert elements to type Complex{T}\nFlatIQUFourier{P,T,M<:AbstractMatrix{Complex{T}}}(Il::M, Ql::M, Ul::M) # specify everything explicilty\n\nConstruct a FlatIQUFourier object. The top form of the constructor is most convenient for interactive work, while the others may be more useful for low-level code.\n\n\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.FlatIQUMap","page":"API","title":"CMBLensing.FlatIQUMap","text":"# main constructor:\nFlatIQUMap(Ix::AbstractMatrix, Qx::AbstractMatrix, Ux::AbstractMatrix[, θpix={resolution in arcmin}, ∂mode={fourier∂ or map∂})\n\n# more low-level:\nFlatIQUMap{P}(Ix::AbstractMatrix, Qx::AbstractMatrix, Ux::AbstractMatrix) # specify pixelization P explicilty\nFlatIQUMap{P,T}(Ix::AbstractMatrix, Qx::AbstractMatrix, Ux::AbstractMatrix) # additionally, convert elements to type T\nFlatIQUMap{P,T,M<:AbstractMatrix{T}}(Ix::M, Qx::M, Ux::M) # specify everything explicilty\n\nConstruct a FlatIQUMap object. The top form of the constructor is most convenient for interactive work, while the others may be more useful for low-level code.\n\n\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.FlatMap","page":"API","title":"CMBLensing.FlatMap","text":"# main constructor:\nFlatMap(Ix::AbstractMatrix[, θpix={resolution in arcmin}, ∂mode={fourier∂ or map∂})\n\n# more low-level:\nFlatMap{P}(Ix::AbstractMatrix) # specify pixelization P explicilty\nFlatMap{P,T}(Ix::AbstractMatrix) # additionally, convert elements to type T\nFlatMap{P,T,M<:AbstractMatrix{T}}(Ix::M) # specify everything explicilty\n\nConstruct a FlatMap object. The top form of the constructor is most convenient for interactive work, while the others may be more useful for low-level code.\n\n\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.FlatQUFourier","page":"API","title":"CMBLensing.FlatQUFourier","text":"# main constructor:\nFlatQUFourier(Ql::AbstractMatrix, Ul::AbstractMatrix[, θpix={resolution in arcmin}, ∂mode={fourier∂ or map∂})\n\n# more low-level:\nFlatQUFourier{P}(Ql::AbstractMatrix, Ul::AbstractMatrix) # specify pixelization P explicilty\nFlatQUFourier{P,T}(Ql::AbstractMatrix, Ul::AbstractMatrix) # additionally, convert elements to type Complex{T}\nFlatQUFourier{P,T,M<:AbstractMatrix{Complex{T}}}(Ql::M, Ul::M) # specify everything explicilty\n\nConstruct a FlatQUFourier object. The top form of the constructor is most convenient for interactive work, while the others may be more useful for low-level code.\n\n\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.FlatQUMap","page":"API","title":"CMBLensing.FlatQUMap","text":"# main constructor:\nFlatQUMap(Qx::AbstractMatrix, Ux::AbstractMatrix[, θpix={resolution in arcmin}, ∂mode={fourier∂ or map∂})\n\n# more low-level:\nFlatQUMap{P}(Qx::AbstractMatrix, Ux::AbstractMatrix) # specify pixelization P explicilty\nFlatQUMap{P,T}(Qx::AbstractMatrix, Ux::AbstractMatrix) # additionally, convert elements to type T\nFlatQUMap{P,T,M<:AbstractMatrix{T}}(Qx::M, Ux::M) # specify everything explicilty\n\nConstruct a FlatQUMap object. The top form of the constructor is most convenient for interactive work, while the others may be more useful for low-level code.\n\n\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.ParamDependentOp","page":"API","title":"CMBLensing.ParamDependentOp","text":"ParamDependentOp(recompute_function::Function)\nParamDependentOp(recompute_function!::Function, mem)\n\nCreates an ImplicitOp which depends on some parameters theta and can be evaluated at various values of these parameters. There are two forms to construct this operator. In the first form, recompute_function should be a function which accepts keyword arguments for theta and returns the operator. Each keyword must have a default value; the operator will act as if evaluated at these defaults unless it is explicitly evaluated at other parameters. In the second form, we can preallocate some memory for the results mem, in which case recompute_function! should additionally accept a single positional argument holding this memory, which should then be assigned in-place. \n\nExample:\n\n``julia     Cϕ₀ = Diagonal(...) # some fixed Diagonal operator     Cϕ = ParamDependentOp((;Aϕ=1)->Aϕ*Cϕ₀) # create ParamDependentOp\n\nCϕ(Aϕ=1.1) * ϕ   # Cϕ(Aϕ=1.1) is equal to 1.1*Cϕ₀\nCϕ * ϕ           # Cϕ alone will act like Cϕ(Aϕ=1) because that was the default above\n\n# a version which preallocates the memory:\nCϕ = ParamDependentOp((mem;Aϕ=1)->(@. mem = Aϕ*Cϕ₀), similar(Cϕ₀))\n\n```\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.RK4Solver-Tuple{Function,Any,Any,Any,Any}","page":"API","title":"CMBLensing.RK4Solver","text":"Solve for y(t₁) with 4th order Runge-Kutta assuming dy/dt = F(t,y) and y(t₀) = y₀\n\nArguments\n\nF! : a function F!(v,t,y) which sets v=F(t,y)\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.antilensing-Union{Tuple{PowerLens{N,F}}, Tuple{F}, Tuple{N}} where F where N","page":"API","title":"CMBLensing.antilensing","text":"Create from an existing PowerLens operator one that lenses by -ϕ instead. \n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.beamCℓs-Tuple{}","page":"API","title":"CMBLensing.beamCℓs","text":"beamCℓs(;beamFWHM, ℓmax=8000)\n\nCompute the beam power spectrum, often called W_ell. A map should be multiplied by sqrt of this.\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.conjugate_gradient","page":"API","title":"CMBLensing.conjugate_gradient","text":"conjugate_gradient(M, A, b, x=M\\b; nsteps=length(b), tol=sqrt(eps()), progress=false, callback=nothing, hist=nothing, histmod=1)\n\nCompute x = A\\b (where A is positive definite) by conjugate gradient. M is the preconditioner and should approximate A, and M \\ x should be fast.\n\nThe solver will stop either after nsteps iterations or when dot(r,r)<tol (where r=A*x-b is the residual  at that step), whichever occurs first.\n\nInfo from the iterations of the solver can be returned if hist is specified. hist can be one or a tuple of:\n\n:i - current iteration number\n:x - current solution\n:r - current residual r=A*x-b\n:res - the norm of r\n:t - the time elapsed (in seconds) since the start of the algorithm\n\nhistmod can be used to include every N-th iteration only in hist. \n\n\n\n\n\n","category":"function"},{"location":"api/#CMBLensing.fftsyms-Union{Tuple{n}, Tuple{m}, Tuple{Val{m},Val{n}}} where n where m","page":"API","title":"CMBLensing.fftsyms","text":"Arguments m and n refer to the sizes of an m×n matrix (call it A) that is the output of a real FFT (thus m=n÷2+1)\n\nReturns a tuple of (ireal, iimag, negks) where these are\n\n* ireal - m×n mask corrsponding to unique real entries of A\n* iimag - m×n mask corrsponding to unique imaginary entries of A\n* negks - m×n matrix of giving the index into A where the negative k-vector\n          is, s.t. A[i,j] = A[negks[i,j]]'\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.fieldvalues-Tuple{Any}","page":"API","title":"CMBLensing.fieldvalues","text":"Return the type's fields as a tuple\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.get_term_memoizer-Tuple{Any}","page":"API","title":"CMBLensing.get_term_memoizer","text":"All of the terms in the quadratic estimate and normalization expressions look like\n\nC * l[i] * l̂[j] * l̂[k] * ...\n\nwhere C is some field or diagonal covariance. For example, there's a term in the EB estimator that looks like:\n\n(CE * (CẼ+Cn) \\ d[:E])) * l[i] * l̂[j] * l̂[k]\n\n(where note that l̂[j] and l̂[k] are unit vectors, but l[i] is not).  The function get_term_memoizer returns a function term which could be called in the following way to compute this term:\n\nterm((CE * (CẼ+Cn) \\ d[:E])), [i], j, k)\n\n(note that the fact that l[i] is not a unit vector is specified by putting the [i] index in brackets). \n\nAdditionally, all of these terms are symmetric in their indices, i.e. in (i,j,k) in this case. The term function is smart about this, and is memoized so that each unique set of indices is only computed once. This leads to a pretty drastic speedup for terms with many indices like those that arize in the EE and EB normalizations, and lets us write code which is both clear and fast without having to think too hard about these symmetries.\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.rfft2vec-Tuple{AbstractArray{T,2} where T}","page":"API","title":"CMBLensing.rfft2vec","text":"Convert a matrix A which is the output of a real FFT to a real vector, keeping only unqiue real/imaginary entries of A\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.unfold-Union{Tuple{AbstractArray{Complex{T},2}}, Tuple{T}} where T","page":"API","title":"CMBLensing.unfold","text":"Convert an M×N matrix (with M=N÷2+1) which is the output a real FFT to a full N×N one via symmetries.\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.vec2rfft-Tuple{AbstractArray{#s13,1} where #s13<:Real}","page":"API","title":"CMBLensing.vec2rfft","text":"Convert a vector produced by rfft2vec back into a complex matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.Σ-Tuple{Any,Any}","page":"API","title":"CMBLensing.Σ","text":"Σ(ϕ, ds, ::Type{L}=LenseFlow) where {L}\nΣ(L::LenseOp, ds)\n\nAn operator for the data covariance, Cn + PMBLCfL'B'M'P', which can applied and inverted.\n\n\n\n","category":"method"},{"location":"02_posterior/#The-Lensing-Posterior-1","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"","category":"section"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Much of what the CMBLensing package does is centered on the \"CMB lensing posterior\". We refer to either the \"joint posterior\", ","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":" mathcalP(fphithetad) ","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"where","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"f are the CMB fields (T/Q/U)\nphi is the lensing potential\ntheta are any cosmological parameters\nd is the data,","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"or the \"marginal posterior\", ","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":" mathcalP(phithetad) equiv int  mathcalDf  mathcalP(fphithetad) ","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"which is simply the joint posterior marginalized over f. ","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"We assume the following data model, which is generally flexible enough to handle real experiments:","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":" d = mathbbP  mathbbM  mathbbB  mathbbL(phi)  f + n ","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"where ","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"mathbbL(phi) is the lensing operation\nmathbbB is an instrumental transfer function or \"beam\"\nmathbbM is a user-chosen mask\nmathbbP is a pixelization operation which allows one to estimate f on a higher resolution than the data\nn is the instrumental noise. ","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Given this model, the joint posterior (up to an unimportant normalization constant) in the \"unlensed parameterization\", is:","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":" \n-2lnmathcalP(fphithetad) = fracbig(d - mathbbP  mathbbM  mathbbB  mathbbL(phi)  fbig)^2mathbbC_n\n+ fracf^2mathbbC_f(theta) + fracphi^2C_phi(theta) + logdet mathbbC_f(theta) + logdet C_phi(theta)\n","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"where","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"mathbbC_n is the noise covariance\nmathbbC_f is the CMB covariance (i.e. the CMB T, E, and B C_ell's)\nmathbbC_phi is the lensing potential covariance (i.e. C_ell^phiphi)","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"and we have used the slighly sloppy notation x^2mathbbC to mean x^dagger mathbbC^-1 x.","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"It's often useful to parameterize this in terms of the lensed tilde f = mathbbL(phi) f (this reduces correlations), in which case we have the \"\"lensed parametrization\":","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":" \n-2lnmathcalP(tilde fphithetad) = fracbig(d - mathbbP  mathbbM  mathbbB  tilde fbig)^2mathbbC_n\n+ fracbig(mathbbL(phi)^-1 tilde fbig)^2mathbbC_f(theta) + fracphi^2C_phi(theta) + logdet mathbbC_f(theta) + logdet C_phi(theta)\n","category":"page"},{"location":"02_posterior/#Posterior-basics-1","page":"The Lensing Posterior","title":"Posterior basics","text":"","category":"section"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"using CMBLensing\nusing PyPlot","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"CMBLensing uses the function lnP to compute the log of the joint posterior probability. ","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"To evaluate this posterior, we need the arguments of the probability distribution, f, phi, and theta. We also need the data d and host of other operators and covariances which enter the expressions above, which CMBLensing stores in a DataSet object.","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"First lets load up some simulated data. We'll use 1muK-arcmin noise and a border mask:","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"@unpack f, ϕ, ds, L = load_sim_dataset(\n    θpix      = 2,\n    Nside     = 256,\n    T         = Float64,\n    use       = :P,\n    μKarcminT = 1,\n    L         = LenseFlow{RK4Solver{10}},\n    seed      = 0,\n    pixel_mask_kwargs = (edge_padding_deg=1, apodization_deg=0, num_ptsrcs=0),\n    bandpass_mask     = LowPass(5000)\n);","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"The DataSet object, ds, stores all the aforementioned quantities:","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"fieldnames(typeof(ds))","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"(:d, :Cϕ, :Cf, :Cf̃, :Cn, :Cn̂, :M, :M̂, :B, :B̂, :D, :G, :P, :L)","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"For example, the data is:","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"plot(ds.d);","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"(Image: png)","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"We can now evaluate the posterior, for example at the true f and phi:","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"-2*lnP(0, f, ϕ, ds)","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"307989.9304561836","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"The first argument, 0, indicates that this is in the unlensed parameterization. We could also use 1 for the lensed parametriation. (The 0 and 1 refer to auxillary \"time\" variable in the LenseFlow expansion, f(x+tnablaphi); at t=0 we have the unlensed field, and at t=1 we have the lensed field). If we use the lensed parametrization, then the f argument to the function is expected to be the lensed field.","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"-2*lnP(1, L(ϕ)*f, ϕ, ds)","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"307989.8639035257","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"We expect minus twice the posterior evaluated at the truth to be distributed like a chi^2 distribution where the degrees of freedom equals the number of pixels in d, f, and phi (i.e. in each of the three Gaussian terms in the posterior). Since these maps are 256x256 and d and f have both Q and U maps, this is:","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"(2+2+1)*256^2","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"327680","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"which the previous result is within a few sigma of.","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Above, we didn't specify any cosmological parameters, theta. Because of that, they were fixed at their fiducial values (i.e. the fiducial values which generated the simulated data in the call to load_sim_dataset earlier). Current only two parameters can be varied, r (tensor-to-scalar ratio), and A_phi (the amplitude of C_ell^phi phi). They can be specified as follows, with non-specified parameters left at their fiducial:","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"-2*lnP(0, f, ϕ, (Aϕ=1.1,), ds)","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"308226.8865766122","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"You can see the slight change compared to what we got above. We can even compute a whole slice through the posterior along A_phi:","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Aϕs = range(0.5,1.5,length=50)\nplot(Aϕs, [lnP(0, f, ϕ, (Aϕ=Aϕ,), ds) for Aϕ in Aϕs])\nxlabel(raw\"$A_\\phi$\")\nylabel(raw\"$\\mathcal{P}(f_{\\rm true}, \\phi_{\\rm true}, A_\\phi\\,|\\,d)$\");","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"(Image: png)","category":"page"},{"location":"02_posterior/#Wiener-filtering-1","page":"The Lensing Posterior","title":"Wiener filtering","text":"","category":"section"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"If we fix phi and theta then maximize the joint posterior, mathcalP(fphithetad), over f, we get","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"\nhat f_rm wf = big mathbbC_f(theta)^-1 + mathbbA^daggermathbbC_n^-1mathbbA big^-1 mathbbA^daggermathbbC_n^-1d\n","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"where","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"\nmathbbA = mathbbM  mathbbP  mathbbB  mathbbL(phi)\n","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"This is simply the Wiener filter of the data, and we can compute it by inverting the operator in brackets above with e.g. Conjugate Gradient. ","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"In CMBLensing, the argmaxf_lnP function performs this task. Its arguments are similar to lnP,","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"f_wf = argmaxf_lnP(ϕ, (Aϕ=1,), ds, tol=1e-1, progress=true);","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"\u001b[32mConjugate Gradient: 100%|███████████████████████████████| Time: 0:00:22\u001b[39m","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Since Wiener filtering is the best-fit of the joint posterior at a fixed phi, it is effectively delensing the data by a given phi. Here we are Wiener filtering at the true phi, so this is perfect delensing. ","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Note below the large amount of B mode power in the data, as well as the aliasing near the border mask, and how this is removed in the Wiener filtered B, which visually is tracing the true B map up to the level of the noise.","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"plot([ds.d, f_wf, f], title=[\"data \", \"Wiener filtered \", \"true \"] .* [\"E\" \"B\"]);","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"(Image: png)","category":"page"},{"location":"02_posterior/#Posterior-gradients-1","page":"The Lensing Posterior","title":"Posterior gradients","text":"","category":"section"},{"location":"02_posterior/#Marginal-posterior-1","page":"The Lensing Posterior","title":"Marginal posterior","text":"","category":"section"},{"location":"03_joint_MAP_example/#Joint-maximum-a-posteriori-estimate-1","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"","category":"section"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"using CMBLensing\nusing PyPlot","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"┌ Info: Precompiling CMBLensing [b60c06c0-7e54-11e8-3788-4bd722d65317]\n└ @ Base loading.jl:1242\n┌ Warning: Package CMBLensing does not have Setfield in its dependencies:\n│ - If you have CMBLensing checked out for development and have\n│   added Setfield as a dependency but haven't updated your primary\n│   environment's manifest file, try `Pkg.resolve()`.\n│ - Otherwise you may need to report an issue with CMBLensing\n└ Loading Setfield into CMBLensing from project dependency, future warnings for CMBLensing are suppressed.\nWARNING: Method definition inv(LinearAlgebra.Diagonal{T, V} where V<:AbstractArray{T, 1} where T) in module LinearAlgebra at /home/marius/src/julia-1.2/usr/share/julia/stdlib/v1.2/LinearAlgebra/src/diagonal.jl:496 overwritten in module CMBLensing at /home/marius/work/baylens/src/util.jl:168.\n  ** incremental compilation may be fatally broken for this module **\n\nWARNING: Method definition (::Type{CMBLensing.DataSet{Td, TCn, TCf, TCf̃, TCϕ, TCn̂, TB̂, TM, TB, TD, TG, TP} where TP where TG where TD where TB where TM where TB̂ where TCn̂ where TCϕ where TCf̃ where TCf where TCn where Td})(CMBLensing.DataSet{Td, TCn, TCf, TCf̃, TCϕ, TCn̂, TB̂, TM, TB, TD, TG, TP} where TP where TG where TD where TB where TM where TB̂ where TCn̂ where TCϕ where TCf̃ where TCf where TCn where Td) in module CMBLensing at /home/marius/.julia/packages/Parameters/NholY/src/Parameters.jl:526 overwritten at /home/marius/work/baylens/src/likelihood.jl:52.\n  ** incremental compilation may be fatally broken for this module **\n\nWARNING: Method definition Type(Any, Type{CMBLensing.DataSet{Td, TCn, TCf, TCf̃, TCϕ, TCn̂, TB̂, TM, TB, TD, TG, TP} where TP where TG where TD where TB where TM where TB̂ where TCn̂ where TCϕ where TCf̃ where TCf where TCn where Td}, CMBLensing.DataSet{Td, TCn, TCf, TCf̃, TCϕ, TCn̂, TB̂, TM, TB, TD, TG, TP} where TP where TG where TD where TB where TM where TB̂ where TCn̂ where TCϕ where TCf̃ where TCf where TCn where Td) in module CMBLensing overwritten.\n  ** incremental compilation may be fatally broken for this module **","category":"page"},{"location":"03_joint_MAP_example/#Compute-spectra-1","page":"Joint maximum a posteriori estimate","title":"Compute spectra","text":"","category":"section"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"First, compute the fiducial CMB power spectra which generate our simulated data,","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"Cℓ = camb(r=0.05);","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"Next, chose the noise power-spectra we are assuming,","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"Cℓn = noisecls(1, ℓknee=100);","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"Plot these up for reference,","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"loglog(Cℓ[:f̃][:BB],c=\"C0\")\nloglog(Cℓ[:f][:BB],\"--\",c=\"C0\")\nloglog(Cℓ[:f̃][:EE],c=\"C1\")\nloglog(Cℓ[:f][:EE],\"--\",c=\"C1\")\nloglog(Cℓn[:BB],\"k:\")\nlegend([\"lensed B\",\"unlensed B\",\"lensed E\",\"unlensed E\", \"noise (beam not deconvolved)\"]);","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"(Image: png)","category":"page"},{"location":"03_joint_MAP_example/#Configure-the-type-of-data-1","page":"Joint maximum a posteriori estimate","title":"Configure the type of data","text":"","category":"section"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"These describe the setup of the simulated data we are going to work with (and can be changed),","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"Θpix  = 3        # pixel size in arcmin\nNside = 128      # number of pixels per side in the map\nuse   = :P       # type of data to use (can be :T, :P, or :TP)\nT     = Float32  # data type (Float32 is ~2 as fast as Float64);","category":"page"},{"location":"03_joint_MAP_example/#Generate-simulated-data-1","page":"Joint maximum a posteriori estimate","title":"Generate simulated data","text":"","category":"section"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"With these defined, the following generates the simulated data and returns the true unlensed and lensed CMB fields, f and f̃ ,and the true lensing potential, ϕ, as well as a number of other quantities stored in the \"DataSet\" object ds. ","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"@unpack f, f̃, ϕ, ds = load_sim_dataset(\n    seed = 3,\n    Cℓ = Cℓ,\n    Cℓn = Cℓn,\n    θpix = Θpix,\n    T = T,\n    Nside = Nside,\n    use = use,\n)\n\n@unpack Cf, Cϕ = ds;","category":"page"},{"location":"03_joint_MAP_example/#Examine-simulated-data-1","page":"Joint maximum a posteriori estimate","title":"Examine simulated data","text":"","category":"section"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"The true phi map,","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"plot(ϕ, title = raw\"true $\\phi$\");","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"(Image: png)","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"The \"true\" unlensed field, f,","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"plot(f, title = \"true unlensed \" .* [\"E\" \"B\"]);","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"(Image: png)","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"And the \"true\" lensed field,","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"plot(LenseFlow(ϕ)*f, title = \"true lensed \" .* [\"E\" \"B\"]);","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"(Image: png)","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"The data (stored in the ds object) is basically f̃ with a beam applied plus a sample of the noise,","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"plot(ds.d, title = \"data \" .* [\"E\" \"B\"]);","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"(Image: png)","category":"page"},{"location":"03_joint_MAP_example/#Run-the-minimizer-1","page":"Joint maximum a posteriori estimate","title":"Run the minimizer","text":"","category":"section"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"Now we compute the maximum of the joint posterior, mathcalPbig(f phi bigdbig)","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"@time fbf, ϕbf, tr = MAP_joint(ds, nsteps=30, progress=:verbose, αmax=0.3);","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"(step=1, χ²=43095.78, Ncg=5)\n(step=2, χ²=37498.30, Ncg=7, α=0.015109)\n(step=3, χ²=35814.16, Ncg=6, α=0.021678)\n(step=4, χ²=35104.89, Ncg=6, α=0.015126)\n(step=5, χ²=34614.47, Ncg=6, α=0.023681)\n(step=6, χ²=34313.39, Ncg=6, α=0.014259)\n(step=7, χ²=34055.08, Ncg=6, α=0.026641)\n(step=8, χ²=33880.53, Ncg=6, α=0.012995)\n(step=9, χ²=33706.83, Ncg=6, α=0.032235)\n(step=10, χ²=33588.29, Ncg=6, α=0.011610)\n(step=11, χ²=33441.90, Ncg=6, α=0.046751)\n(step=12, χ²=33346.99, Ncg=6, α=0.010170)\n(step=13, χ²=33167.36, Ncg=6, α=0.102652)\n(step=14, χ²=33073.17, Ncg=6, α=0.008815)\n(step=15, χ²=32881.18, Ncg=6, α=0.241844)\n(step=16, χ²=32815.46, Ncg=5, α=0.008552)\n(step=17, χ²=32802.16, Ncg=5, α=0.046773)\n(step=18, χ²=32792.16, Ncg=4, α=0.010362)\n(step=19, χ²=32766.15, Ncg=5, α=0.126376)\n(step=20, χ²=32749.73, Ncg=5, α=0.009135)\n(step=21, χ²=32707.56, Ncg=4, α=0.299424)\n(step=22, χ²=32696.19, Ncg=4, α=0.011517)\n(step=23, χ²=32694.19, Ncg=3, α=0.023547)\n(step=24, χ²=32692.72, Ncg=3, α=0.019082)\n(step=25, χ²=32691.43, Ncg=3, α=0.017517)\n(step=26, χ²=32690.20, Ncg=3, α=0.020820)\n(step=27, χ²=32689.04, Ncg=3, α=0.016119)\n(step=28, χ²=32687.90, Ncg=3, α=0.021766)\n(step=29, χ²=32686.87, Ncg=3, α=0.014998)\n(step=30, χ²=32685.76, Ncg=3, α=0.025862)\n 47.164667 seconds (54.99 M allocations: 17.468 GiB, 8.81% gc time)","category":"page"},{"location":"03_joint_MAP_example/#Examine-results-1","page":"Joint maximum a posteriori estimate","title":"Examine results","text":"","category":"section"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"The expected value of the final best-fit chi^2 (=-2log mathcalP) is given by the number degrees of freedom in the data, i.e. the total number of pixels in T and/or EB.","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"χ² = -2tr[end][:lnPcur]","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"32685.76359250259","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"dof = getproperty((T=1, P=2, TP=3),use) * Nside^2","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"32768","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"Here's how far away our final chi^2 is from this expectation, in units of sigma. We expect this should be somewhere in the range (-3,3) for about 99.7% of simulated datasets.","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"(χ² - dof)/sqrt(2dof)","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"-0.3212359667867588","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"Here's the best-fit phi relative to the truth,","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"plot(10^6*[ϕ ϕbf], title=[\"true\" \"best-fit\"] .* raw\" $\\phi$\");","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"(Image: png)","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"Here is the difference in terms of the power spectra. Note the best-fit has high-ell power suppressed, like a Wiener filter solution (in fact what we're doing here is akin to a non-linear Wiener filter). In the high S/N region (elllesssim1000), the difference is approixmately equal to the noise, which you can see is almost two orders of magnitude below the signal.","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"loglog(ℓ⁴ * Cℓ[:f][:ϕϕ], \"k\")\nloglog(ℓ⁴ * get_Cℓ(ϕ))\nloglog(ℓ⁴ * get_Cℓ(ϕbf))\nloglog(ℓ⁴ * get_Cℓ(ϕbf-ϕ))\nxlim(80,3000)\nylim(5e-9,2e-6)\nlegend([\"theory\",raw\"true $\\phi$\", raw\"best-fit $\\phi$\", \"difference\"])\nxlabel(raw\"$\\ell$\")\nylabel(raw\"$\\ell^4 C_\\ell$\");","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"(Image: png)","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"The best-fit unlensed fields relative to truth,","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"plot([f,fbf], title = [\"true\", \"best-fit\"] .* \" unlensed \" .* [\"E\" \"B\"]);","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"(Image: png)","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"The best-fit lensed field (bottom row) relative to truth (top row),","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"plot([f̃, LenseFlow(ϕbf)*fbf], title = [\"true\", \"best-fit\"] .* \" lensed \" .* [\"E\" \"B\"]);","category":"page"},{"location":"03_joint_MAP_example/#","page":"Joint maximum a posteriori estimate","title":"Joint maximum a posteriori estimate","text":"(Image: png)","category":"page"},{"location":"04_from_python/#Calling-from-Python-1","page":"Calling from Python","title":"Calling from Python","text":"","category":"section"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"If you predominantly use Python, it's very easy to call CMBLensing.jl directly from your Python session. This is made possible by the PyJulia package. You can install it into your Python environment with, e.g.:","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"$ pip install --user julia","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"Important: If your Python executable is statically-linked (this is quite often the case, e.g. its the default on Ubuntu and Conda) you need one extra step. Basically, instead of running python or ipython at the command line to launch your interpreter, run python-jl  or python-jl -m IPython, respectively. If you use Jupyter, you'll need to edit your kernel.json file (you can find its location via jupyter kernelspec list) and change it to use python-jl.","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"The wrapper script python-jl does some special initializion but otherwise drops you into the Python/IPython interpreter that you are familiar with. ","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"The PyJulia docs also give instructions on how to install a dynamically-linked Python executable which is the most ideal solution, and only slightly more work than above.","category":"page"},{"location":"04_from_python/#Basics-of-calling-Julia-1","page":"Calling from Python","title":"Basics of calling Julia","text":"","category":"section"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"Once PyJulia is installed, you can access any Julia package Foo from the Python package julia.Foo, and everything pretty much works transparently.","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"import julia.Base","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"julia.Base.cos(1) # <--- this is Julia's cosine function","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"0.5403023058681398","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"You can also run arbitrary Julia code with the %julia cell magic (this is helpful if you want to use Julia language features or syntax which don't exist in Python):","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"%load_ext julia.magic","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"Initializing Julia runtime. This may take some time...","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"For example, 1:10 is not valid Python syntax, but we can do:","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"%julia 1:10","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"range(1, 11)","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"The cell magic lets you interpolate values from Python into the Julia expression, which can be a convenient way to pass values back and forth:","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"x = %julia 1 + 2","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"%julia 2 * $x","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"6","category":"page"},{"location":"04_from_python/#Calling-CMBLensing.jl-1","page":"Calling from Python","title":"Calling CMBLensing.jl","text":"","category":"section"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"In Julia, using CMBLensing imports all of the CMBLensing symbols into the current namespace. In Python this is:","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"from julia.CMBLensing import *","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"Things then generally work the same as in Julia. For example, following this example, we load a simulated dataset:","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"sim = load_sim_dataset(\n    θpix  = 2, \n    Nside = 256, \n    T     = julia.Base.Float32, \n    use   = \"P\"\n)","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"Note however we did have to use julia.Base.Float32 instead of just Float32 since that is a Julia type and it's not exported in CMBLensing. ","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"The next step in the example is to \"unpack\" the variables in the sim objects for convenience, i.e.","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"# julia code:\n@unpack f, ϕ, ds = sim","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"There's two problems doing this in Python. First, there's no macro @unpack so we have to do it by hand. Second, Python does not differentiate between the characters ϕ (\\phi) and φ (\\varphi), and maps both of them back to φ (\\varphi) in Julia, which unfortunately is the wrong one for CMBLensing (which instead makes extensive use of the variable name ϕ (\\phi))","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"To get around this, we can wrap code which needs to access  ϕ (\\phi) in %julia magic. The whole thing thus looks like:","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"f, ϕ, ds = %julia $sim.f, $sim.ϕ, $sim.ds","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"Plotting works the same. We first enable inline plotting:","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"%pylab inline --no-import-all\n%config InlineBackend.rc = {\"figure.dpi\": 100} # this matches default Julia DPI","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"Populating the interactive namespace from numpy and matplotlib","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"plot(ϕ);","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"(Image: png)","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"The call to from julia.CMBLensing import * only import CMBLensing into the Python namespace, if we want to use CMBLensing functions from %julia blocks we also need to load it there.","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"%julia using CMBLensing","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"Lϕ = %julia LenseFlow($ϕ)","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"In Julia you can do addition / multiplication / etc... with operators and fields. This does not work in PyJulia (yet), so you need to use %julia magic:","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"f̃ = %julia $Lϕ * $f","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"plot(f̃);","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"(Image: png)","category":"page"},{"location":"04_from_python/#Beyond-1","page":"Calling from Python","title":"Beyond","text":"","category":"section"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"This should give you all the tools needed to run any of the other examples in CMBLensing docs from Python. As a general rule, try doing things natively from Python, and if that doesn't work, wrap things in %julia magic to just call the Julia code directly.","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"using CMBLensing","category":"page"},{"location":"05_field_basics/#Field-Basics-1","page":"Field Basics","title":"Field Basics","text":"","category":"section"},{"location":"05_field_basics/#Base-Fields-1","page":"Field Basics","title":"Base Fields","text":"","category":"section"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Much of CMBLensing is based on manipilating CMB \"fields\", like temperature, Q or U polarization, or the lensing potential phi. These types are all encompassed by the abstract type Field, with some concrete examples including FlatMap for a flat-sky map projection, or FlatQUMap for Q/U polarization, etc...","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Flat fields are just thing wrappers around Julia arrays, e.g.","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Ix = rand(2,2)","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"2×2 Array{Float64,2}:\n 0.732042  0.182965\n 0.998787  0.732902","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f = FlatMap(Ix)","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:\n 0.7320418196232326 \n 0.9987870573048432 \n 0.18296504638359612\n 0.7329019559062799","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"You can see the pixels in the 2x2 map have been splayed out into a length-4 array (at least for displaying purposes). This is intentional, as even though the maps themselves are two-dimensional, it is extremely useful conceptually to think of fields as vectors (which they are, in fact, as they form an abstract vector space). This tie to vector spaces is deeply rooted in CMBLensing, to the extent that Field objects are a subtype of Julia's own AbstractVector type, ","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f isa AbstractVector","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"true","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"That said, the data itself is stored as the original 2x2 matrix, and can be accessed as follows,","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f.Ix","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"2×2 Array{Float64,2}:\n 0.732042  0.182965\n 0.998787  0.732902","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"But since Fields are vectors, they can be tranposed,","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f'","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"1×4 LinearAlgebra.Adjoint{Float64,FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}}:\n 0.732042  0.998787  0.182965  0.732902","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"inner products can be computed,","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f' * f","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"1.7803892228763662e-7","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"and they can be added with each other as well as multiplied by scalars,","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"2*f+f","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:\n 2.1961254588696977\n 2.9963611719145296\n 0.5488951391507884\n 2.19870586771884","category":"page"},{"location":"05_field_basics/#Diagonal-operators-1","page":"Field Basics","title":"Diagonal operators","text":"","category":"section"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Vector spaces have linear operators which act on the vectors. Linear operators correpsond to matrices, thus for a map with N total pixels, a general linear operator would be an N-by-N matrix, which for even modest map sizes becomes far too large to actually store. Thus, an important class of linear operators are ones which are diagonal, since these can actually be stored. CMBLensing uses Julia's builtin Diagonal to represent these. Diagonal(f) takes a vector f and puts it on the diagonal of the matrix:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Diagonal(f)","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4×4 Diagonal{Float64,FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}}:\n 0.732042   ⋅         ⋅         ⋅      \n  ⋅        0.998787   ⋅         ⋅      \n  ⋅         ⋅        0.182965   ⋅      \n  ⋅         ⋅         ⋅        0.732902","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Multiplying this operator by the original map is then a matrix-vector product:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Diagonal(f) * f","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:\n 0.5358852256772934 \n 0.9975755858396681 \n 0.03347620819815148\n 0.5371452769712507","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Note that this is also equal to the the pointwise multiplication of f with itself:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f .* f","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:\n 0.5358852256772934 \n 0.9975755858396681 \n 0.03347620819815148\n 0.5371452769712507","category":"page"},{"location":"05_field_basics/#Field-Tuples-1","page":"Field Basics","title":"Field Tuples","text":"","category":"section"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"You can put Fields together into tuples. For example, ","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"a = FlatMap(rand(2,2))\nb = FlatMap(rand(2,2));","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"FieldTuple(a,b)","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"8-element Field2Tuple{CMBLensing.BasisTuple{Tuple{Map,Map}}, Float64}:\n 0.5505235821680978  \n 0.950054953812133   \n 0.014057456492081677\n 0.36803238748144085 \n 0.006160415105918249\n 0.36772974041695905 \n 0.7377151845932439  \n 0.3910706904663759","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"The components can also have names:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"ft = FieldTuple(a=a, b=b)","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"8-element Field2Tuple{(:a, :b), CMBLensing.BasisTuple{Tuple{Map,Map}}, Float64}:\n 0.5505235821680978  \n 0.950054953812133   \n 0.014057456492081677\n 0.36803238748144085 \n 0.006160415105918249\n 0.36772974041695905 \n 0.7377151845932439  \n 0.3910706904663759","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"which can be accessed later:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"ft.a","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:\n 0.5505235821680978  \n 0.950054953812133   \n 0.014057456492081677\n 0.36803238748144085","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"FieldTuples have all of the same behavior of individual fields. Indeed, spin fields like QU or IQU are simply special FieldTuples:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"FlatQUMap(Q=a, U=b) isa FieldTuple","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"true","category":"page"},{"location":"05_field_basics/#Field-Vectors-1","page":"Field Basics","title":"Field Vectors","text":"","category":"section"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"in progress","category":"page"},{"location":"05_field_basics/#Basis-Conversion-1","page":"Field Basics","title":"Basis Conversion","text":"","category":"section"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"All fields are tagged as to which basis they are stored in. You can convert them to other bases by calling the basis type on them:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:\n 0.7320418196232326 \n 0.9987870573048432 \n 0.18296504638359612\n 0.7329019559062799","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f′ = Fourier(f)","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4-element FlatFourier{2×2 map, 1′ pixels, fourier∂, Array{Complex{Float64}}}:\n   3.564317699947486e-8 + 0.0im\n -1.0998296613404274e-8 + 0.0im\n   1.097512962242427e-8 + 0.0im\n   3.813755469023178e-9 + 0.0im","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Basis conversion is usually done automatically for you. E.g. here f′ is automatically converted to a FlatMap before addition:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f + f′","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:\n 1.4640836392464651 \n 1.9975741146096864 \n 0.36593009276719235\n 1.4658039118125599","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"A key feature of Diagonal operators is they convert the field they are acting on to the right basis before multiplication:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Diagonal(f) * f′","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:\n 0.5358852256772935\n 0.9975755858396682\n 0.0334762081981515\n 0.5371452769712508","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"A FlatMap times a FlatFourier doesn't have a natural linear algebra meaning so its an error:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f * f′","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"MethodError: no method matching *(::FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}, ::FlatFourier{2×2 map, 1′ pixels, fourier∂, Array{Complex{Float64}}})\nClosest candidates are:\n  *(::Any, ::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n  *(!Matched::PyCall.PyObject, ::Any) at /home/marius/.julia/packages/PyCall/ttONZ/src/pyoperators.jl:13\n  *(!Matched::FuncOp, ::Field) at /home/marius/work/baylens/src/specialops.jl:105\n  ...\n\n\n\nStacktrace:\n\n [1] top-level scope at In[63]:1","category":"page"},{"location":"05_field_basics/#Properties-and-indices-1","page":"Field Basics","title":"Properties and indices","text":"","category":"section"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"FlatMap and FlatFourier can be indexed directly like arrays. If given 1D indices, this is the index into the vector representation:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:\n 0.7320418196232326 \n 0.9987870573048432 \n 0.18296504638359612\n 0.7329019559062799","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f[1], f[2], f[3], f[4]","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"(0.7320418196232326, 0.9987870573048432, 0.18296504638359612, 0.7329019559062799)","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f[5]","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"BoundsError: attempt to access 2×2 Array{Float64,2} at index [5]\n\n\n\nStacktrace:\n\n [1] getindex at ./array.jl:728 [inlined]\n\n [2] getindex(::FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}, ::Int64) at /home/marius/work/baylens/src/flat_s0.jl:23\n\n [3] top-level scope at In[74]:1","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Or with a 2D index, this indexes directly into the 2D map:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f[1,1], f[2,1], f[1,2], f[2,2]","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"(0.7320418196232326, 0.9987870573048432, 0.18296504638359612, 0.7329019559062799)","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Note: there is no overhead to indexing f in this way as compared to working directly on the underlying array.","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"For other fields which are built on FieldTuples, 1D indexing will instead index the tuple indices:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"ft","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"8-element Field2Tuple{(:Q, :U), CMBLensing.BasisTuple{Tuple{Map,Map}}, Float64}:\n 0.17774917746454766\n 0.2511905982997429 \n 0.6912012950726147 \n 0.373539849474948  \n 0.39985459058015005\n 0.9001296871952931 \n 0.41989219275007916\n 0.5612169223732928","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"ft[1]","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:\n 0.17774917746454766\n 0.2511905982997429 \n 0.6912012950726147 \n 0.373539849474948","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"ft[2]","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:\n 0.39985459058015005\n 0.9001296871952931 \n 0.41989219275007916\n 0.5612169223732928","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"ft[3]","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"BoundsError: attempt to access (Q = [0.17774917746454766, 0.2511905982997429, 0.6912012950726147, 0.373539849474948], U = [0.39985459058015005, 0.9001296871952931, 0.41989219275007916, 0.5612169223732928])\n  at index [3]\n\n\n\nStacktrace:\n\n [1] getindex at ./namedtuple.jl:90 [inlined]\n\n [2] getindex(::Field2Tuple{(:Q, :U), CMBLensing.BasisTuple{Tuple{Map,Map}}, Float64}, ::Int64) at /home/marius/work/baylens/src/field_tuples.jl:41\n\n [3] top-level scope at In[91]:1","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"To get the underlying data arrays, use the object's properties:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f.Ix","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"2×2 Array{Float64,2}:\n 0.732042  0.182965\n 0.998787  0.732902","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"You can always find out what properties are available by typing f.<Tab>. For example, if you typed ft then hit <Tab> you'd get:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"ft |> propertynames","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"(:fs, :Q, :U, :Qx, :Ux)","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"For a FieldTuple like the FlatQUMap object, ft, you can get each individual Q or U field:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"ft.Q","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:\n 0.6922927799412399\n 0.6961360514468293\n 0.8130790577325409\n 0.8044087072888599","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Or ft.Qx which is shorthand for ft.Q.Ix:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"ft.Q.Ix === ft.Qx","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"true","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"If you convert f to Fourier space, it would have the Il property to get the Fourier coefficients:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Fourier(f).Il","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"2×2 Array{Complex{Float64},2}:\n  3.56432e-8+0.0im  1.09751e-8+0.0im\n -1.09983e-8+0.0im  3.81376e-9+0.0im","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"For convenience, you can also use the [:...] syntax which does the conversion automatically:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f[:Il]","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"2×2 Array{Complex{Float64},2}:\n  3.56432e-8+0.0im  1.09751e-8+0.0im\n -1.09983e-8+0.0im  3.81376e-9+0.0im","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"This works between any bases. For example. ft is originally QUMap but we can convert to EBFourier and get the El coefficients:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"ft[:El]","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"2×2 Array{Complex{Float64},2}:\n -4.04808e-8-0.0im  3.08475e-9+0.0im\n 6.50065e-11+0.0im    6.633e-9+0.0im","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"The general rule for these two ways of accessing the underlying data is:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Properties (i.e. f.Ix) are type-stable and get you the underlying data arrays, even recursively from FieldTuples. If these arrays are modified, they affect the original field.\nIndices (i.e. f[:Ix]) are not type-stable, and may not be one of the underlying data arrays (because a basis conversion may have been performed). They should be used for getting (not setting) data, and in non-performance-critical code. ","category":"page"},{"location":"06_sampling/#","page":"-","title":"-","text":"using Revise\nusing CMBLensing\nusing CMBLensing: @ntpack\nusing Random, Loess, Parameters, Random.DSFMT, Interpolations\nusing JLD2","category":"page"},{"location":"06_sampling/#","page":"-","title":"-","text":"┌ Info: Recompiling stale cache file /home/marius/.julia/compiled/v1.2/CMBLensing/niPeo.ji for CMBLensing [b60c06c0-7e54-11e8-3788-4bd722d65317]\n└ @ Base loading.jl:1240\n┌ Warning: Package CMBLensing does not have Setfield in its dependencies:\n│ - If you have CMBLensing checked out for development and have\n│   added Setfield as a dependency but haven't updated your primary\n│   environment's manifest file, try `Pkg.resolve()`.\n│ - Otherwise you may need to report an issue with CMBLensing\n└ Loading Setfield into CMBLensing from project dependency, future warnings for CMBLensing are suppressed.\nWARNING: Method definition inv(LinearAlgebra.Diagonal{T, V} where V<:AbstractArray{T, 1} where T) in module LinearAlgebra at /home/marius/src/julia-1.2/usr/share/julia/stdlib/v1.2/LinearAlgebra/src/diagonal.jl:496 overwritten in module CMBLensing at /home/marius/work/baylens/src/util.jl:168.\n  ** incremental compilation may be fatally broken for this module **\n\nWARNING: Method definition (::Type{CMBLensing.DataSet{Td, TCn, TCf, TCf̃, TCϕ, TCn̂, TB̂, TM, TB, TD, TG, TP} where TP where TG where TD where TB where TM where TB̂ where TCn̂ where TCϕ where TCf̃ where TCf where TCn where Td})(CMBLensing.DataSet{Td, TCn, TCf, TCf̃, TCϕ, TCn̂, TB̂, TM, TB, TD, TG, TP} where TP where TG where TD where TB where TM where TB̂ where TCn̂ where TCϕ where TCf̃ where TCf where TCn where Td) in module CMBLensing at /home/marius/.julia/packages/Parameters/NholY/src/Parameters.jl:526 overwritten at /home/marius/work/baylens/src/likelihood.jl:52.\n  ** incremental compilation may be fatally broken for this module **\n\nWARNING: Method definition Type(Any, Type{CMBLensing.DataSet{Td, TCn, TCf, TCf̃, TCϕ, TCn̂, TB̂, TM, TB, TD, TG, TP} where TP where TG where TD where TB where TM where TB̂ where TCn̂ where TCϕ where TCf̃ where TCf where TCn where Td}, CMBLensing.DataSet{Td, TCn, TCf, TCf̃, TCϕ, TCn̂, TB̂, TM, TB, TD, TG, TP} where TP where TG where TD where TB where TM where TB̂ where TCn̂ where TCϕ where TCf̃ where TCf where TCn where Td) in module CMBLensing overwritten.\n  ** incremental compilation may be fatally broken for this module **","category":"page"},{"location":"06_sampling/#","page":"-","title":"-","text":"rfid = 0.1\nCℓ = camb(r=rfid);","category":"page"},{"location":"06_sampling/#","page":"-","title":"-","text":"@unpack f, f̃, ϕ, ds, ds₀ = load_sim_dataset(\n    seed  = 0,\n    rfid = rfid,\n    Cℓ = Cℓ,\n    θpix = 3,\n    Nside = 256,\n    use = :P,\n    T = Float32,\n    μKarcminT = 10/√2,\n)\n@unpack Cf, Cϕ = ds₀;","category":"page"},{"location":"06_sampling/#","page":"-","title":"-","text":"# mixing matrices\nσ²len=deg2rad(5/60)^2\nNϕ = nan2zero.(ϕqe(ds₀)[2])/2\nds = DataSet(ds,\n    G = ParamDependentOp(let SN=Cϕ/Nϕ, G₀=sqrt(1+2/SN)\n        (;Aϕ=1, _...)-> @. sqrt(1+2/(Aϕ*SN))/G₀\n    end),\n    D = (@. nan2zero(sqrt(1 + 2/(Cf/(ds.Cn̂+σ²len))))),\n);","category":"page"},{"location":"06_sampling/#","page":"-","title":"-","text":"sample_joint(\n    ds,\n    Cℓ = Cℓ,\n    θrange = (Aϕ=range(0.5, 1.9, length=25),),\n    θstart = (Aϕ=1,),\n    symp_kwargs = (N=25, ϵ=0.02),\n    nsamps_per_chain = 10,\n    nchains = 1, \n    pmap = map,\n    nchunk = 2,\n    nsavemaps = 10,\n    nburnin_always_accept = Inf,\n    nburnin_fixθ = 0,\n    metadata = (@ntpack f f̃ ϕ ds₀),\n    progress = :summary,\n    filename = \"testchain.jld2\"\n);","category":"page"},{"location":"06_sampling/#","page":"-","title":"-","text":"\u001b[32mGibbs chain: 100%|██████████████████████████████████████| Time: 0:05:22\u001b[39m","category":"page"},{"location":"06_sampling/#","page":"-","title":"-","text":"@load \"testchain.jld2\" ","category":"page"},{"location":"06_sampling/#","page":"-","title":"-","text":"2-element Array{Symbol,1}:\n :chains\n :rundat","category":"page"},{"location":"06_sampling/#","page":"-","title":"-","text":"using Statistics","category":"page"},{"location":"06_sampling/#","page":"-","title":"-","text":"getindex.(chains[1][2:end],:timing)","category":"page"},{"location":"06_sampling/#","page":"-","title":"-","text":"10-element Array{NamedTuple{(:f, :θ, :ϕ),Tuple{Float64,Float64,Float64}},1}:\n (f = 3.115016167, θ = 8.954657676, ϕ = 27.103998331) \n (f = 0.96117215, θ = 9.723460596, ϕ = 20.927602568)  \n (f = 0.716426248, θ = 9.267559107, ϕ = 19.746085108) \n (f = 0.634769225, θ = 8.661115741, ϕ = 19.175055979) \n (f = 0.62653508, θ = 8.689044008, ϕ = 20.336935978)  \n (f = 1.265916839, θ = 10.242237773, ϕ = 19.286341166)\n (f = 1.010267911, θ = 9.267745122, ϕ = 20.404541676) \n (f = 0.835300153, θ = 8.484976122, ϕ = 22.227946742) \n (f = 0.647691704, θ = 8.461052793, ϕ = 22.776909722) \n (f = 0.578629753, θ = 8.642342834, ϕ = 21.026899381)","category":"page"},{"location":"06_sampling/#","page":"-","title":"-","text":"plot([rundat[:metadata].ϕ mean(getindex.(filter(s->haskey(s,:ϕ),chains[1]),:ϕ))])","category":"page"},{"location":"06_sampling/#","page":"-","title":"-","text":"(Image: png)","category":"page"},{"location":"06_sampling/#","page":"-","title":"-","text":"(PyPlot.Figure(PyObject <Figure size 1120x400 with 4 Axes>), PyCall.PyObject[PyObject <matplotlib.axes._subplots.AxesSubplot object at 0x7f6cb1b65080> PyObject <matplotlib.axes._subplots.AxesSubplot object at 0x7f6cb1b24908>], Symbol[:Tx])","category":"page"},{"location":"06_sampling/#","page":"-","title":"-","text":"plot(first.(getindex.(chains[1],:θ)))","category":"page"},{"location":"06_sampling/#","page":"-","title":"-","text":"(Image: png)","category":"page"},{"location":"06_sampling/#","page":"-","title":"-","text":"1-element Array{PyCall.PyObject,1}:\n PyObject <matplotlib.lines.Line2D object at 0x7f6c96fe71d0>","category":"page"},{"location":"#CMBLensing.jl-1","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"","category":"section"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"(Image: ) (Image: Binder)","category":"page"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"This repository contains tools written in Julia (and easily callable from Python) to analyze the gravitationally lensed Cosmic Microwave Background. ","category":"page"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"Some things this code can do:","category":"page"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"Lense flat-sky temperature and polarization maps using the following algorithms:\nTaylor series expansion to any order\nThe Taylens algorithm (Næss & Louis 2013)\nThe LenseFlow algorithm (Millea, Anderes, & Wandelt 2017)\nCompute the quadratic estimate of phi given some data (Hu & Okamoto 2003)\nCompute best-fit of mathcalP(fphid), i.e. the joint maximum a posteriori estimate of the lensing potential and CMB fields, and draw Monte-Carlo samples from this poterior, with the option to sample over cosmological parameters as well (Millea, Anderes, & Wandelt 2017)\nCompute best-fit of mathcalP(phid), i.e. the marginal maximum a posteriori estimate of the lensing potential (Carron & Lewis 2017)","category":"page"},{"location":"#Documentation-1","page":"CMBLensing.jl","title":"Documentation","text":"","category":"section"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"The best place to get started is to read the documentation (which is very much a work-in-progress, many things this package can do are not documented yet, but are planned to be added soon). ","category":"page"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"Most of the pages in the documentation are Jupyter notebooks, and you can click the \"launch binder\" link at the top of each page to launch a Jupyterlab server running the notebook in your browser (courtesy of binder). You can also find the notebooks in this folder if you want to run them locally (which will usually lead to higher performance).","category":"page"},{"location":"#Installation-1","page":"CMBLensing.jl","title":"Installation","text":"","category":"section"},{"location":"#Requirements-1","page":"CMBLensing.jl","title":"Requirements","text":"","category":"section"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"Julia 1.0 or higher\nPython 3 + matplotlib (used for plotting)\n(recommended) pycamb to generate C_ell's\n(optional) healpy for experimental curved sky support","category":"page"},{"location":"#Native-installation-1","page":"CMBLensing.jl","title":"Native installation","text":"","category":"section"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"To install the Julia package locally, run:","category":"page"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"pkg> add https://github.com/marius311/CMBLensing.jl#master","category":"page"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"(type ] at the Julia REPL to reach the pkg> prompt)","category":"page"},{"location":"#Docker-installation-1","page":"CMBLensing.jl","title":"Docker installation","text":"","category":"section"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"Also provided is a Docker container which includes a Jupyterlab server and all the recommended and optional dependencies to run and use CMBLensing.jl. Launch this container with:","category":"page"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"git clone https://github.com/marius311/CMBLensing.jl.git\ncd CMBLensing.jl\ndocker-compose pull\ndocker-compose up","category":"page"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"The first time you run this, it will automatically download the (~500Mb) container from the Docker hub. The command will prompt you with the URL which you should open in a browser to access the notebook.","category":"page"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"To run the notebook on a different port than the default 8888, do PORT=1234 docker-compose up where 1234 is whatever port number you want.","category":"page"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"You can also build the container locally by replacing docker-compose pull with docker-compose build above.","category":"page"}]
}
