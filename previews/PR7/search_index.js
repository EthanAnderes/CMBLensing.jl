var documenterSearchIndex = {"docs":
[{"location":"01_lense_a_map/#Lensing-a-flat-sky-map-1","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"","category":"section"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"using CMBLensing, PyPlot","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"First we load a simulated unlensed field, f, and lensing potential, phi,","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"@unpack f,ϕ = load_sim_dataset(\n    θpix  = 2,       # size of the pixels in arcmin\n    Nside = 256,     # number of pixels per side in the map\n    T     = Float32, # Float32 or Float64 (former is ~twice as fast)\n    pol   = :I       # :I for Intensity, :P for polarization, or :IP for both\n);","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"We can lense the map with LenseFlow,","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"f̃ = LenseFlow(ϕ) * f;","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"And flip between lensed and unlensed maps,","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"animate([f,f̃], fps=1)","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"The difference between lensed and unlensed,","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"plot(f-f̃);","category":"page"},{"location":"01_lense_a_map/#Loading-your-own-data-1","page":"Lensing a flat-sky map","title":"Loading your own data","text":"","category":"section"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"CMBLensing flat-sky Field objects like f or ϕ  are just thin wrappers around arrays. You can get the underlying data arrays for I(mathbfx), Q(mathbfx), and U(mathbfx) with f[:Ix], f[:Qx], and f[:Ux] respectively, or the Fourier coefficients, I(mathbfl), Q(mathbfl), and U(mathbfl) with f[:Il], f[:Ql], and f[:Ul],","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"mapdata = f[:Ix]","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"If you have your own map data in an array you'd like to load into a CMBLensing Field object, you can construct it as follows:","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"FlatMap(mapdata, θpix=3)","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"For more info on Field objects, see Field Basics.","category":"page"},{"location":"01_lense_a_map/#Inverse-lensing-1","page":"Lensing a flat-sky map","title":"Inverse lensing","text":"","category":"section"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"You can inverse lense a map with the \\ operator (which does A \\ b ≡ inv(A) * b):","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"LenseFlow(ϕ) \\ f;","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"Note that this is true inverse lensing, rather than lensing by the negative deflection (which is often called \"anti-lensing\"). This means that lensing then inverse lensing a map should get us back the original map. Lets check that this is the case:","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"Ns = [7 10 20]\nplot([f - (LenseFlow(ϕ,N) \\ (LenseFlow(ϕ,N) * f)) for N in Ns],\n    title=[\"ODE steps = $N\" for N in Ns]);","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"A cool feature of LenseFlow is that inverse lensing is trivially done by running the LenseFlow ODE in reverse. Note that as we crank up the number of ODE steps above, we recover the original map to higher and higher precision.","category":"page"},{"location":"01_lense_a_map/#Other-lensing-algorithms-1","page":"Lensing a flat-sky map","title":"Other lensing algorithms","text":"","category":"section"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"We can also lense via:","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"PowerLens: the standard Taylor series expansion to any order:","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":" f(x+nabla x) approx f(x) + (nabla f)(nabla phi) + frac12 (nabla nabla f) (nabla phi)^2 +  ","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"TayLens (Næss&Louis 2013): like PowerLens, but first a nearest-pixel permute step, then a Taylor expansion around the now-smaller residual displacement","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"plot([(PowerLens(ϕ,2)*f - f̃) (Taylens(ϕ,2)*f - f̃)], \n    title=[\"PowerLens - LenseFlow\" \"TayLens - LenseFlow\"]);","category":"page"},{"location":"01_lense_a_map/#Benchmarking-1","page":"Lensing a flat-sky map","title":"Benchmarking","text":"","category":"section"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"LenseFlow is highly optimized code since it appears on the inner-most loop of our analysis algorithms. To benchmark LenseFlow, note that there is first a precomputation step, which caches some data in preparation for applying it to a field of a given type. This was done automatically when evaluating LenseFlow(ϕ) * f but we can benchmark it separately since in many cases this only needs to be done once for a given phi, e.g. when Wiener filtering at fixed phi,","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"using BenchmarkTools","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"@benchmark cache(LenseFlow(ϕ),f)","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"Once cached, it's very fast and memory non-intensive to repeatedly apply the operator:","category":"page"},{"location":"01_lense_a_map/#","page":"Lensing a flat-sky map","title":"Lensing a flat-sky map","text":"@benchmark Lϕ * f setup=(Lϕ=cache(LenseFlow(ϕ),f))","category":"page"},{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Modules = [CMBLensing]\nOrder   = [:function, :type, :macro, :constant]","category":"page"},{"location":"api/#CMBLensing.MAP_joint-Tuple{Any}","page":"API","title":"CMBLensing.MAP_joint","text":"MAP_joint(ds::DataSet; kwargs...)\n\nCompute the maximum a posteriori (i.e. \"MAP\") estimate of the joint posterior, mathcalP(fphithetad), or compute a quasi-sample. \n\nKeyword arguments:\n\nϕstart — Starting point of the maximizer (default: phi=0)\nNϕ — Noise to use in the approximate hessian matrix. Can also give Nϕ=:qe         to use the EB quadratic estimate noise (default: :qe)\nquasi_sample — true to iterate quasi-samples, or an integer to compute                  a specific quasi-sample.\nnsteps — The number of iterations for the maximizer\nNcg — Maximum number of conjugate gradient steps during the f update\ncgtol — Conjugrate gradient tolerance (will stop at cgtol or Ncg, whichever is first)\nαtol — Absolute tolerance on alpha in the linesearch in the phi quasi-Newton-Rhapson step, x^prime = x - alpha H^-1 g\nαmax — Maximum value for alpha in the linesearch\nprogress — false, :summary, or :verbose, to control progress output\n\nReturns a tuple (f, ϕ, tr) where f is the best-fit (or quasi-sample) field, ϕ is the lensing potential, and tr contains info about the run. \n\n\n\n","category":"method"},{"location":"api/#CMBLensing.MAP_marg-Tuple{Any}","page":"API","title":"CMBLensing.MAP_marg","text":"MAP_marg(ds; kwargs...)\n\nCompute the maximum a posteriori (i.e. \"MAP\") estimate of the marginal posterior, mathcalP(phithetad).\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.argmaxf_lnP-Tuple{Field,DataSet}","page":"API","title":"CMBLensing.argmaxf_lnP","text":"argmaxf_lnP(ϕ,                ds::DataSet; kwargs...)\nargmaxf_lnP(ϕ, θ::NamedTuple, ds::DataSet; kwargs...)\nargmaxf_lnP(Lϕ,               ds::DataSet; kwargs...)\n\nComputes either the Wiener filter at fixed phi, or a sample from this slice along the posterior.\n\nKeyword arguments: \n\nwhich — :wf, :sample, or fluctuation to compute 1) the Wiener filter, i.e. the best-fit of mathcalP(fphid), 2) a sample from mathcalP(fphid), or 3) a sample minus the Wiener filter, i.e. the fluctuation on top of the mean.\nguess — starting guess for f for the conjugate gradient solver\nkwargs... — all other arguments are passed to conjugate_gradient\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.gradhess-Tuple{Any}","page":"API","title":"CMBLensing.gradhess","text":"gradhess(f)\n\nCompute the gradient g^i = nabla^i f, and the hessian, H_j^i = nabla_j nabla^i f.\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.lnP-Tuple{Any,Any,Any,DataSet}","page":"API","title":"CMBLensing.lnP","text":"lnP(t, fₜ, ϕₜ,                ds::DataSet)\nlnP(t, fₜ, ϕₜ, θ::NamedTuple, ds::DataSet)\n\nCompute the log posterior probability in the joint parameterization as a function of the field, f_t, the lensing potential, phi_t, and possibly some cosmological parameters, theta. The subscript t can refer to either a \"time\", e.g. passing t=0 corresponds to the unlensed parametrization and t=1 to the lensed one, or can be :mix correpsonding to the mixed parametrization. In all cases, the arguments fₜ and ϕₜ should then be f and phi in that particular parametrization.\n\nIf any parameters theta are provided, we also include the determinant terms for covariances which depend on theta. In the mixed parametrization, we also include any Jacobian determinant terms that depend on theta. \n\nThe argument ds should be a DataSet and stores the masks, data, etc... needed to construct the posterior. \n\n\n\n","category":"method"},{"location":"api/#CMBLensing.load_camb_Cℓs-Tuple{}","page":"API","title":"CMBLensing.load_camb_Cℓs","text":"load_camb_Cℓs(;path_prefix, custom_tensor_params=nothing, \n    unlensed_scalar_postfix, unlensed_tensor_postfix, lensed_scalar_postfix, lenspotential_postfix)\n\nLoad some Cℓs from CAMB files. \n\npath_prefix specifies the prefix for the files, which are then expected to have the normal CAMB postfixes: \"scalCls.dat\", \"tensCls.dat\", \"lensedCls.dat\", \"lenspotentialCls.dat\", unless otherwise specified via the other keyword arguments. custom_tensor_params can be used to call CAMB directly for the unlensedtensors, rather than reading them from a file (since alot of times this file doesn't get saved). The value should be a Dict/NamedTuple which will be passed to a call to camb, e.g. `customtensor_params=(r=0,)` for zero tensors. \n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.load_sim_dataset-Tuple{}","page":"API","title":"CMBLensing.load_sim_dataset","text":"load_sim_dataset\n\nCreate a DataSet object with some simulated data. E.g.\n\n@unpack f,ϕ,ds = load_sim_dataset(;\n    θpix  = 2,\n    Nside = 128,\n    pol   = :I,\n    T     = Float32\n);\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.mix-Tuple{Any,Any,DataSet}","page":"API","title":"CMBLensing.mix","text":"mix(f, ϕ,                ds::DataSet)\nmix(f, ϕ, θ::NamedTuple, ds::DataSet)\n\nCompute the mixed (f°, ϕ°) from the unlensed field f and lensing potential ϕ, given the definition of the mixing matrices in ds evaluated at parameters θ (or at fiducial values if no θ provided).\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.noiseCℓs-Tuple{}","page":"API","title":"CMBLensing.noiseCℓs","text":"noiseCℓs(;μKarcminT, beamFWHM=0, ℓmax=8000, ℓknee=100, αknee=3)\n\nCompute the (:TT,:EE,:BB,:TE) noise power spectra given white noise + 1/f. Polarization noise is scaled by sqrt2 relative to μKarcminT. beamFWHM is in arcmin.\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.pixwin-Tuple{Any,Any}","page":"API","title":"CMBLensing.pixwin","text":"pixwin(θpix, ℓ)\n\nReturns the pixel window function for square flat-sky pixels of width θpix (in arcmin) evaluated at some ℓs. This is the scaling of k-modes, the scaling of the power spectrum will be pixwin^2. \n\n\n\n","category":"method"},{"location":"api/#CMBLensing.quadratic_estimate-Union{Tuple{F2}, Tuple{F1}, Tuple{Tuple{DataSet{F1,TCn,TCf,TCf̃,TCϕ,TCn̂,TM,TM̂,TB,TB̂,TD,TG,TP,TL} where TL where TP where TG where TD where TB̂ where TB where TM̂ where TM where TCn̂ where TCϕ where TCf̃ where TCf where TCn,DataSet{F2,TCn,TCf,TCf̃,TCϕ,TCn̂,TM,TM̂,TB,TB̂,TD,TG,TP,TL} where TL where TP where TG where TD where TB̂ where TB where TM̂ where TM where TCn̂ where TCϕ where TCf̃ where TCf where TCn},Any}} where F2 where F1","page":"API","title":"CMBLensing.quadratic_estimate","text":"quadratic_estimate(ds::DataSet, which; wiener_filtered=true)\nquadratic_estimate((ds1::DataSet,ds2::DataSet), which; wiener_filtered=true)\n\nCompute quadratic estimate of ϕ given data.\n\nThe ds or (ds1,ds2) tuple contain the DataSet object(s) which houses the data and covariances used in the estimate. Note that only the Fourier-diagonal approximations for the beam, mask, and noise,, i.e. ds.B̂, ds.M̂, and ds.Cn̂, are accounted for. To account full operators (if they are not actually Fourier-diagonal), you should compute the impact using Monte Carlo.\n\nIf a tuple is passed in, the result will come from correlating the data from ds1 with that from ds2, which can be useful for debugging / isolating various noise terms. \n\nAn optional keyword argument AL can be passed in in case the QE normalization was already computed, in which case it won't be recomputed during the calculation.\n\nReturns a NamedTuple (ϕqe, AL, Nϕ) where ϕqe is the (possibly Wiener filtered, depending on wiener_filtered option) quadratic estimate, AL is the normalization (which is already applied to ϕqe, it does not need to be applied again), and Nϕ is the analytic N0 noise bias (Nϕ==AL if using unlensed weights, currently only Nϕ==AL is always returned, no matter the weights)\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.resimulate-Tuple{DataSet}","page":"API","title":"CMBLensing.resimulate","text":"resimulate(ds::DataSet; f=..., ϕ=...)\n\nResimulate the data in a given dataset, potentially at a fixed f and/or ϕ (both are resimulated if not provided)\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.sample_joint-Union{Tuple{DataSet{#s315,TCn,TCf,TCf̃,TCϕ,TCn̂,TM,TM̂,TB,TB̂,TD,TG,TP,TL} where TL where TP where TG where TD where TB̂ where TB where TM̂ where TM where TCn̂ where TCϕ where TCf̃ where TCf where TCn where #s315<:Union{FieldTuple{CMBLensing.BasisTuple{Tuple{Fourier,EBFourier}},NamedTuple{(:I, :P),Tuple{FlatFourier{P,T,M},FieldTuple{EBFourier,NamedTuple{(:E, :B),Tuple{FlatFourier{P,T,M},FlatFourier{P,T,M}}},Complex{T}}}},Complex{T}}, FieldTuple{CMBLensing.BasisTuple{Tuple{Fourier,QUFourier}},NamedTuple{(:I, :P),Tuple{FlatFourier{P,T,M},FieldTuple{QUFourier,NamedTuple{(:Q, :U),Tuple{FlatFourier{P,T,M},FlatFourier{P,T,M}}},Complex{T}}}},Complex{T}}, FieldTuple{CMBLensing.BasisTuple{Tuple{Map,EBMap}},NamedTuple{(:I, :P),Tuple{FlatMap{P,T,M},FieldTuple{EBMap,NamedTuple{(:E, :B),Tuple{FlatMap{P,T,M},FlatMap{P,T,M}}},T}}},T}, FieldTuple{CMBLensing.BasisTuple{Tuple{Map,QUMap}},NamedTuple{(:I, :P),Tuple{FlatMap{P,T,M},FieldTuple{QUMap,NamedTuple{(:Q, :U),Tuple{FlatMap{P,T,M},FlatMap{P,T,M}}},T}}},T}, FieldTuple{EBFourier,NamedTuple{(:E, :B),Tuple{FlatFourier{P,T,M},FlatFourier{P,T,M}}},Complex{T}}, FieldTuple{EBMap,NamedTuple{(:E, :B),Tuple{FlatMap{P,T,M},FlatMap{P,T,M}}},T}, FieldTuple{QUFourier,NamedTuple{(:Q, :U),Tuple{FlatFourier{P,T,M},FlatFourier{P,T,M}}},Complex{T}}, FieldTuple{QUMap,NamedTuple{(:Q, :U),Tuple{FlatMap{P,T,M},FlatMap{P,T,M}}},T}, FlatFourier{P,T,M}, FlatMap{P,T,M}}}, Tuple{M}, Tuple{T}, Tuple{P}} where M where T where P","page":"API","title":"CMBLensing.sample_joint","text":"sample_joint(ds::DataSet; kwargs...)\n\nSample the joint posterior, mathcalP(fphithetad). \n\nKeyword arguments: \n\nnsamps_per_chain — (required) The number of samples per chain\nnchains — Run nchains chains in parallel (default: 1)\nnchunk — Do nchunk steps between parallel chain communication (default: 1)\nnsavemaps — Save maps into chain every nsavemaps steps (default: 1)\nnburnin_always_accept — The first nburnin_always_accept steps, always accept                           HMC steps independent of integration error (default: 0)\nnburnin_fixθ — For the first nburnin_fixθ steps, fix θ at its starting point (default: 0)\nNϕ — Noise to use in the HMC mass matrix. can also give Nϕ=:qe to use the         EB quadratic estimate noise (default: :qe)\nchains — nothing to start a new chain; the return value from a previous call to            sample_joint to resume those chains; :resume to resume chains            from a file given by filename\nθrange — Range and density to grid sample parameters as a NamedTuple,             e.g. (Aϕ=range(0.7,1.3,length=20),). \nθstart — Starting values of parameters as a NamedTuple, e.g. (Aϕ=1.2,),             or nothing to randomly sample from θrange\nϕstart — Starting ϕ, either a Field object, :quasi_sample, or :best_fit\nmetadata — Does nothing, but is saved into the chain file\nnhmc — The number of HMC passes per ϕ Gibbs step (default: 1)\nsymp_kwargs — an array of NamedTupe kwargs to pass to symplectic_integrate.                  E.g. [(N=50,ϵ=0.1),(N=25,ϵ=0.01)] would do 50 large steps then 25                  smaller steps per each Gibbs pass. If specified, nhmc is ignored.\nwf_kwargs — Keyword arguments to pass to argmaxf_lnP in the Wiener Filter Gibbs step.\nMAP_kwargs — Keyword arguments to pass to MAP_joint when computing the starting point.\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.symplectic_integrate-Union{Tuple{T}, Tuple{AbstractArray{T,1},Any,Any,Any}, Tuple{AbstractArray{T,1},Any,Any,Any,Any}} where T","page":"API","title":"CMBLensing.symplectic_integrate","text":"symplectic_integrate(x₀, p₀, Λ, U, δUδx, N=50, ϵ=0.1, progress=false)\n\nDo a symplectic integration of the potential energy U (with gradient δUδx) starting from point x₀ with momentum p₀ and mass matrix Λ. The number of steps is N and the step size ϵ. \n\nReturns ΔH, xᵢ, pᵢ corresponding to change in Hamiltonian, and final position and momenta. If hist is specified a trace of requested variables throughout each step is also returned. \n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.ud_grade-Union{Tuple{P}, Tuple{∂mode}, Tuple{N}, Tuple{θ}, Tuple{M}, Tuple{T}, Tuple{Union{FlatFourier{P,T,M}, FlatMap{P,T,M}},Any}} where P<:Flat{N,θ,∂mode} where ∂mode where N where θ where M where T","page":"API","title":"CMBLensing.ud_grade","text":"ud_grade(f::Field, θnew, mode=:map, deconv_pixwin=true, anti_aliasing=true)\n\nUp- or down-grades field f to new resolution θnew (only in integer steps). Two modes are available specified by the mode argument: \n\n:map     — Up/downgrade by replicating/averaging pixels in map-space\n:fourier — Up/downgrade by extending/truncating the Fourier grid\n\nFor :map mode, two additional options are possible. If deconv_pixwin is true, deconvolves the pixel window function from the downgraded map so the spectrum of the new and old maps are the same. If anti_aliasing is true, filters out frequencies above Nyquist prior to down-sampling. \n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.unmix-Tuple{Any,Any,DataSet}","page":"API","title":"CMBLensing.unmix","text":"unmix(f°, ϕ°,                ds::DataSet)\nunmix(f°, ϕ°, θ::NamedTuple, ds::DataSet)\n\nCompute the unmixed/unlensed (f, ϕ) from the mixed field f° and mixed lensing potential ϕ°, given the definition of the mixing matrices in ds evaluated at parameters θ (or at fiducial values if no θ provided). \n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.BilinearLens","page":"API","title":"CMBLensing.BilinearLens","text":"BilinearLens(ϕ)\n\nBilinearLens is a lensing operator that computes lensing with bilinear interpolation. The action of the operator, as well as its adjoint, inverse, inverse-adjoint, and gradient w.r.t. ϕ can all be computed. The log-determinant of the operation is non-zero and can't be computed. \n\nInternally, BilinearLens forms a sparse matrix with the interpolation weights, which can be applied and adjoint-ed extremely fast (e.g. at least an order of magnitude faster than LenseFlow). Inverse and inverse-adjoint lensing is somewhat slower as it is implemented with several steps of the preconditioned generalized minimal residual algorithm, taking anti-lensing as the preconditioner.\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.FlatEBFourier","page":"API","title":"CMBLensing.FlatEBFourier","text":"# main constructor:\nFlatEBFourier(El::AbstractMatrix, Bl::AbstractMatrix[, θpix={resolution in arcmin}, ∂mode={fourier∂ or map∂})\n\n# more low-level:\nFlatEBFourier{P}(El::AbstractMatrix, Bl::AbstractMatrix) # specify pixelization P explicilty\nFlatEBFourier{P,T}(El::AbstractMatrix, Bl::AbstractMatrix) # additionally, convert elements to type Complex{T}\nFlatEBFourier{P,T,M<:AbstractMatrix{Complex{T}}}(El::M, Bl::M) # specify everything explicilty\n\nConstruct a FlatEBFourier object. The top form of the constructor is most convenient for interactive work, while the others may be more useful for low-level code.\n\n\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.FlatEBMap","page":"API","title":"CMBLensing.FlatEBMap","text":"# main constructor:\nFlatEBMap(Ex::AbstractMatrix, Bx::AbstractMatrix[, θpix={resolution in arcmin}, ∂mode={fourier∂ or map∂})\n\n# more low-level:\nFlatEBMap{P}(Ex::AbstractMatrix, Bx::AbstractMatrix) # specify pixelization P explicilty\nFlatEBMap{P,T}(Ex::AbstractMatrix, Bx::AbstractMatrix) # additionally, convert elements to type T\nFlatEBMap{P,T,M<:AbstractMatrix{T}}(Ex::M, Bx::M) # specify everything explicilty\n\nConstruct a FlatEBMap object. The top form of the constructor is most convenient for interactive work, while the others may be more useful for low-level code.\n\n\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.FlatFourier","page":"API","title":"CMBLensing.FlatFourier","text":"# main constructor:\nFlatFourier(Il::AbstractMatrix[, θpix={resolution in arcmin}, ∂mode={fourier∂ or map∂})\n\n# more low-level:\nFlatFourier{P}(Il::AbstractMatrix) # specify pixelization P explicilty\nFlatFourier{P,T}(Il::AbstractMatrix) # additionally, convert elements to type Complex{T}\nFlatFourier{P,T,M<:AbstractMatrix{Complex{T}}}(Il::M) # specify everything explicilty\n\nConstruct a FlatFourier object. The top form of the constructor is most convenient for interactive work, while the others may be more useful for low-level code.\n\n\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.FlatIEBFourier","page":"API","title":"CMBLensing.FlatIEBFourier","text":"# main constructors:\nFlatIEBFourier(Il::AbstractMatrix, El::AbstractMatrix, Bl::AbstractMatrix[, θpix={resolution in arcmin}, ∂mode={fourier∂ or map∂})\nFlatIEBFourier(I::FlatFourier, E::FlatFourier, B::FlatFourier)\n\n# more low-level:\nFlatIEBFourier{P}(Il::AbstractMatrix, El::AbstractMatrix, Bl::AbstractMatrix) # specify pixelization P explicilty\nFlatIEBFourier{P,T}(Il::AbstractMatrix, El::AbstractMatrix, Bl::AbstractMatrix) # additionally, convert elements to type Complex{T}\nFlatIEBFourier{P,T,M<:AbstractMatrix{Complex{T}}}(Il::M, El::M, Bl::M) # specify everything explicilty\n\nConstruct a FlatIEBFourier object. The top form of the constructors is most convenient for interactive work, while the others may be more useful for low-level code.\n\n\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.FlatIEBMap","page":"API","title":"CMBLensing.FlatIEBMap","text":"# main constructors:\nFlatIEBMap(Ix::AbstractMatrix, Ex::AbstractMatrix, Bx::AbstractMatrix[, θpix={resolution in arcmin}, ∂mode={fourier∂ or map∂})\nFlatIEBMap(I::FlatMap, E::FlatMap, B::FlatMap)\n\n# more low-level:\nFlatIEBMap{P}(Ix::AbstractMatrix, Ex::AbstractMatrix, Bx::AbstractMatrix) # specify pixelization P explicilty\nFlatIEBMap{P,T}(Ix::AbstractMatrix, Ex::AbstractMatrix, Bx::AbstractMatrix) # additionally, convert elements to type T\nFlatIEBMap{P,T,M<:AbstractMatrix{T}}(Ix::M, Ex::M, Bx::M) # specify everything explicilty\n\nConstruct a FlatIEBMap object. The top form of the constructors is most convenient for interactive work, while the others may be more useful for low-level code.\n\n\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.FlatIQUFourier","page":"API","title":"CMBLensing.FlatIQUFourier","text":"# main constructors:\nFlatIQUFourier(Il::AbstractMatrix, Ql::AbstractMatrix, Ul::AbstractMatrix[, θpix={resolution in arcmin}, ∂mode={fourier∂ or map∂})\nFlatIQUFourier(I::FlatFourier, Q::FlatFourier, U::FlatFourier)\n\n# more low-level:\nFlatIQUFourier{P}(Il::AbstractMatrix, Ql::AbstractMatrix, Ul::AbstractMatrix) # specify pixelization P explicilty\nFlatIQUFourier{P,T}(Il::AbstractMatrix, Ql::AbstractMatrix, Ul::AbstractMatrix) # additionally, convert elements to type Complex{T}\nFlatIQUFourier{P,T,M<:AbstractMatrix{Complex{T}}}(Il::M, Ql::M, Ul::M) # specify everything explicilty\n\nConstruct a FlatIQUFourier object. The top form of the constructors is most convenient for interactive work, while the others may be more useful for low-level code.\n\n\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.FlatIQUMap","page":"API","title":"CMBLensing.FlatIQUMap","text":"# main constructors:\nFlatIQUMap(Ix::AbstractMatrix, Qx::AbstractMatrix, Ux::AbstractMatrix[, θpix={resolution in arcmin}, ∂mode={fourier∂ or map∂})\nFlatIQUMap(I::FlatMap, Q::FlatMap, U::FlatMap)\n\n# more low-level:\nFlatIQUMap{P}(Ix::AbstractMatrix, Qx::AbstractMatrix, Ux::AbstractMatrix) # specify pixelization P explicilty\nFlatIQUMap{P,T}(Ix::AbstractMatrix, Qx::AbstractMatrix, Ux::AbstractMatrix) # additionally, convert elements to type T\nFlatIQUMap{P,T,M<:AbstractMatrix{T}}(Ix::M, Qx::M, Ux::M) # specify everything explicilty\n\nConstruct a FlatIQUMap object. The top form of the constructors is most convenient for interactive work, while the others may be more useful for low-level code.\n\n\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.FlatMap","page":"API","title":"CMBLensing.FlatMap","text":"# main constructor:\nFlatMap(Ix::AbstractMatrix[, θpix={resolution in arcmin}, ∂mode={fourier∂ or map∂})\n\n# more low-level:\nFlatMap{P}(Ix::AbstractMatrix) # specify pixelization P explicilty\nFlatMap{P,T}(Ix::AbstractMatrix) # additionally, convert elements to type T\nFlatMap{P,T,M<:AbstractMatrix{T}}(Ix::M) # specify everything explicilty\n\nConstruct a FlatMap object. The top form of the constructor is most convenient for interactive work, while the others may be more useful for low-level code.\n\n\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.FlatQUFourier","page":"API","title":"CMBLensing.FlatQUFourier","text":"# main constructor:\nFlatQUFourier(Ql::AbstractMatrix, Ul::AbstractMatrix[, θpix={resolution in arcmin}, ∂mode={fourier∂ or map∂})\n\n# more low-level:\nFlatQUFourier{P}(Ql::AbstractMatrix, Ul::AbstractMatrix) # specify pixelization P explicilty\nFlatQUFourier{P,T}(Ql::AbstractMatrix, Ul::AbstractMatrix) # additionally, convert elements to type Complex{T}\nFlatQUFourier{P,T,M<:AbstractMatrix{Complex{T}}}(Ql::M, Ul::M) # specify everything explicilty\n\nConstruct a FlatQUFourier object. The top form of the constructor is most convenient for interactive work, while the others may be more useful for low-level code.\n\n\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.FlatQUMap","page":"API","title":"CMBLensing.FlatQUMap","text":"# main constructor:\nFlatQUMap(Qx::AbstractMatrix, Ux::AbstractMatrix[, θpix={resolution in arcmin}, ∂mode={fourier∂ or map∂})\n\n# more low-level:\nFlatQUMap{P}(Qx::AbstractMatrix, Ux::AbstractMatrix) # specify pixelization P explicilty\nFlatQUMap{P,T}(Qx::AbstractMatrix, Ux::AbstractMatrix) # additionally, convert elements to type T\nFlatQUMap{P,T,M<:AbstractMatrix{T}}(Qx::M, Ux::M) # specify everything explicilty\n\nConstruct a FlatQUMap object. The top form of the constructor is most convenient for interactive work, while the others may be more useful for low-level code.\n\n\n\n\n\n","category":"type"},{"location":"api/#CMBLensing.ParamDependentOp","page":"API","title":"CMBLensing.ParamDependentOp","text":"ParamDependentOp(recompute_function::Function)\nParamDependentOp(recompute_function!::Function, mem)\n\nCreates an operator which depends on some parameters theta and can be evaluated at various values of these parameters. \n\nThere are two forms to construct this operator. In the first form, recompute_function should be a function which accepts keyword arguments for theta and returns the operator. Each keyword must have a default value; the operator will act as if evaluated at these defaults unless it is explicitly evaluated at other parameters. In the second form, we can preallocate some memory for the results mem, in which case recompute_function! should additionally accept a single positional argument holding this memory, which should then be assigned in-place. \n\nExample:\n\nCϕ₀ = Diagonal(...) # some fixed Diagonal operator\nCϕ = ParamDependentOp((;Aϕ=1)->Aϕ*Cϕ₀) # create ParamDependentOp\n\nCϕ(Aϕ=1.1) * ϕ   # Cϕ(Aϕ=1.1) is equal to 1.1*Cϕ₀\nCϕ * ϕ           # Cϕ alone will act like Cϕ(Aϕ=1) because that was the default above\n\n# a version which preallocates the memory:\nCϕ = ParamDependentOp((mem;Aϕ=1)->(@. mem = Aϕ*Cϕ₀), similar(Cϕ₀))\n\nNote: if you are doing parallel work, global variables referred to in the recompute_function need to be distributed to all workers. A more robust solution is to avoid globals entirely and instead ensure all variables are \"closed\" over (and hence will automatically get distributed). This will happen by default if defining the ParamDependentOp inside any function, or can be forced at the global scope by wrapping everything in a let-block, e.g.:\n\nCϕ = let Cϕ₀=Cϕ₀\n    ParamDependentOp((;Aϕ=1)->Aϕ*Cϕ₀)\nend\n\nAfter executing the code above, Cϕ is now ready to be shipped to any workers and will work regardless of what global variables are defined on these workers. \n\n\n\n","category":"type"},{"location":"api/#CMBLensing.RK4Solver-Tuple{Function,Any,Any,Any,Any}","page":"API","title":"CMBLensing.RK4Solver","text":"RK4Solver(F!::Function, y₀, t₀, t₁, nsteps)\n\nSolve for y(t_1) with 4th order Runge-Kutta assuming dydt = F(ty) and y(t_0) = y_0.\n\nArguments:\n\nF! — a function F!(v,t,y)which setsv=F(t,y)`\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.@BandpowerParamOp","page":"API","title":"CMBLensing.@BandpowerParamOp","text":"macro BandpowerParamOp(C₀, ℓedges, A, Δℓ_bin_taper=10)\n\nCreate a ParamDependentOp which has a keyword argument with name specified by A which controls the amplitude of bandpowers of C₀ in bins specified by ℓedges which have smoothed edges given by Δℓ_bin_taper. E.g.\n\nCfb = @BandpowerParamOp(Cf, [500,1000,1500], :A)\n\nwhere you can now do Cfb(A=[1,2]) to compute a new operator which scales the original Cf by 1 in the bin [500,1000], by 2 in the bin [1000,1500], and leaves it unmodified elsewhere.\n\nThe resulting operator is differentiable in the bandpower arguments.\n\n\n\n\n\n","category":"macro"},{"location":"api/#CMBLensing.@namedtuple-Tuple","page":"API","title":"CMBLensing.@namedtuple","text":"Pack some variables into a NamedTuple. E.g.:\n\n> x = 3\n> y = 4\n> @namedtuple(x, y, z=5)\n(x=3,y=4,z=5)\n\n\n\n\n\n","category":"macro"},{"location":"api/#CMBLensing.@repeated-Tuple{Any,Any}","page":"API","title":"CMBLensing.@repeated","text":"Return a tuple with the expression repeated n times \n\n\n\n\n\n","category":"macro"},{"location":"api/#CMBLensing.LinearInterpolation-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"API","title":"CMBLensing.LinearInterpolation","text":"itp = LinearInterpolation(xdat::AbstractVector, ydat::AbstractVector; extrapolation_bc=NaN)\nitp(x) # interpolate at x\n\nA simple 1D linear interpolation code which is fully Zygote differentiable in either xdat, ydat, or the evaluation point x.\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.antilensing-Union{Tuple{PowerLens{N,F}}, Tuple{F}, Tuple{N}} where F where N","page":"API","title":"CMBLensing.antilensing","text":"Create a PowerLens operator that lenses by -ϕ instead. \n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.beamCℓs-Tuple{}","page":"API","title":"CMBLensing.beamCℓs","text":"beamCℓs(;beamFWHM, ℓmax=8000)\n\nCompute the beam power spectrum, often called W_ell. A map should be multiplied by the square root of this.\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.conjugate_gradient","page":"API","title":"CMBLensing.conjugate_gradient","text":"conjugate_gradient(M, A, b, x=M\\b; nsteps=length(b), tol=sqrt(eps()), progress=false, callback=nothing, hist=nothing, histmod=1)\n\nCompute x=A\\b (where A is positive definite) by conjugate gradient. M is the preconditioner and should be M≈A, and M\\x should be fast.\n\nThe solver will stop either after nsteps iterations or when dot(r,r)<tol (where r=A*x-b is the residual  at that step), whichever occurs first.\n\nInfo from the iterations of the solver can be returned if hist is specified. hist can be one or a tuple of:\n\n:i — current iteration number\n:x — current solution\n:r — current residual r=A*x-b\n:res — the norm of r\n:t — the time elapsed (in seconds) since the start of the algorithm\n\nhistmod can be used to include every N-th iteration only in hist. \n\n\n\n","category":"function"},{"location":"api/#CMBLensing.fftsyms-Union{Tuple{n}, Tuple{m}, Tuple{Val{m},Val{n}}} where n where m","page":"API","title":"CMBLensing.fftsyms","text":"Arguments m and n refer to the sizes of an m×n matrix (call it A) that is the output of a real FFT (thus m=n÷2+1)\n\nReturns a tuple of (ireal, iimag, negks) where these are\n\nireal — m×n mask corrsponding to unique real entries of A\niimag — m×n mask corrsponding to unique imaginary entries of A\nnegks — m×n matrix of giving the index into A where the negative k-vector           is, s.t. A[i,j] = A[negks[i,j]]'\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.fieldvalues-Tuple{Any}","page":"API","title":"CMBLensing.fieldvalues","text":"Return the type's fields as a tuple\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.get_term_memoizer-Tuple{Any}","page":"API","title":"CMBLensing.get_term_memoizer","text":"All of the terms in the quadratic estimate and normalization expressions look like\n\nC * l[i] * l̂[j] * l̂[k] * ...\n\nwhere C is some field or diagonal covariance. For example, there's a term in the EB estimator that looks like:\n\n(CE * (CẼ+Cn) \\ d[:E])) * l[i] * l̂[j] * l̂[k]\n\n(where note that l̂[j] and l̂[k] are unit vectors, but l[i] is not).  The function get_term_memoizer returns a function term which could be called in the following way to compute this term:\n\nterm((CE * (CẼ+Cn) \\ d[:E])), [i], j, k)\n\n(note that the fact that l[i] is not a unit vector is specified by putting the [i] index in brackets). \n\nAdditionally, all of these terms are symmetric in their indices, i.e. in (i,j,k) in this case. The term function is smart about this, and is memoized so that each unique set of indices is only computed once. This leads to a pretty drastic speedup for terms with many indices like those that arize in the EE and EB normalizations, and lets us write code which is both clear and fast without having to think too hard about these symmetries.\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.gmres-Tuple{Any,Any}","page":"API","title":"CMBLensing.gmres","text":"gmres(A, b; maxiter, Pl=I)\n\nSolve A \\ b with maxiter iterations of the generalized minimal residual algorithm. Pl is a left-preconditioner which should approximate inv(A). \n\nNote: the implemenation is memory inefficient and uses O(n * maxiter) memory, where n,n=size(A) (may not be a big deal for small maxiter), although is totally generic and works with CPU or GPU and dense or sparse matrices, unlike IterativeSolver's gmres.\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.grid_and_sample-Union{Tuple{S}, Tuple{Function,NamedTuple{S,#s327} where #s327<:(Tuple{T} where T)}} where S","page":"API","title":"CMBLensing.grid_and_sample","text":"grid_and_sample(lnP::Function; range::NamedTuple; progress=false, nsamples=1)\n\nInterpolate the log pdf lnP with support on range, and return  the integrated log pdf as well nsamples samples (drawn via inverse transform sampling)\n\nlnP should accept a NamedTuple argument and range should be a NamedTuple mapping those same names to range objects specifying where to evaluate lnP, e.g.:\n\ngrid_and_sample(nt->-(nt.x^2+nt.y^2)/2, (x=range(-3,3,length=100),y=range(-3,3,length=100)))\n\nThe return value is (lnP, samples, Px) where lnP is an interpolated/smoothed log PDF which can be evaluated anywhere within the original range, Px are sampled points of the original PDF, and samples is a NamedTuple giving the Monte-Carlo samples of each of the parameters.\n\n(Note: only 1D sampling is currently implemented, but 2D like in the example above is planned)\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.rfft2vec-Tuple{AbstractArray{T,2} where T}","page":"API","title":"CMBLensing.rfft2vec","text":"Convert a matrix A which is the output of a real FFT to a real vector, keeping only unqiue real/imaginary entries of A\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.safe_pyimport-Tuple{Any}","page":"API","title":"CMBLensing.safe_pyimport","text":"safe_pyimport(s)\n\nLike pyimport, but if s fails to import, instead of an error right away, the error will be thrown the first time the user tries to access the contents of the module.\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.unfold-Tuple{AbstractArray{T,2} where T}","page":"API","title":"CMBLensing.unfold","text":"Convert an M×N matrix (with M=N÷2+1) which is the output a real FFT to a full N×N one via symmetries.\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.vec2rfft-Tuple{AbstractArray{#s13,1} where #s13<:Real}","page":"API","title":"CMBLensing.vec2rfft","text":"Convert a vector produced by rfft2vec back into a complex matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.Σ-Tuple{Field,Any}","page":"API","title":"CMBLensing.Σ","text":"Σ(ϕ::Field,  ds; conjgrad_kwargs=())\nΣ(Lϕ,        ds; conjgrad_kwargs=())\n\nAn operator for the data covariance, Cn + PMBLCfL'B'M'P', which can applied and inverted. conjgrad_kwargs are passed to the underlying call to conjugate_gradient.\n\n\n\n","category":"method"},{"location":"api/#LinearAlgebra.logdet-Tuple{Union{CMBLensing.ImplicitOp{B,S,P}, Diagonal{T,#s83} where T where #s83<:(Field{B,S,P,T} where T)} where P where S where B,Any}","page":"API","title":"LinearAlgebra.logdet","text":"logdet(L::LinOp, θ)\n\nIf L depends on θ, evaluates logdet(L(θ)) offset by its fiducial value at L(). Otherwise, returns 0.\n\n\n\n\n\n","category":"method"},{"location":"api/#CMBLensing.@!-Tuple{Any}","page":"API","title":"CMBLensing.@!","text":"Rewrites @! x = f(args...) to x = f!(x,args...)\n\nSpecial cases for * and \\ forward to mul! and ldiv!, respectively.\n\n\n\n\n\n","category":"macro"},{"location":"api/#CMBLensing.@dictpack-Tuple","page":"API","title":"CMBLensing.@dictpack","text":"Pack some variables in a dictionary \n\n> x = 3\n> y = 4\n> @dictpack x y z=>5\nDict(:x=>3,:y=>4,:z=>5)\n\n\n\n\n\n","category":"macro"},{"location":"api/#CMBLensing.@invokelatest-Tuple{Any}","page":"API","title":"CMBLensing.@invokelatest","text":"@invokelatest expr...\n\nRewrites all non-broadcasted function calls anywhere within an expression to use Base.invokelatest. This means functions can be called that have a newer world age, at the price of making things non-inferrable.\n\n\n\n\n\n","category":"macro"},{"location":"api/#CMBLensing.@ondemand-Tuple{Any}","page":"API","title":"CMBLensing.@ondemand","text":"@ondemand(Package.function)(args...; kwargs...)\n@ondemand(Package.Submodule.function)(args...; kwargs...)\n\nJust like calling Package.function or Package.Submodule.function, but Package will be loaded on-demand if it is not already loaded. The call is no longer inferrable.\n\n\n\n\n\n","category":"macro"},{"location":"api/#CMBLensing.@subst-Tuple{Any}","page":"API","title":"CMBLensing.@subst","text":"@subst sum(x*$(y+1) for x=1:2)\n\nbecomes\n\nlet tmp=(y+1)\n    sum(x*tmp for x=1:2)\nend\n\nto aid in writing clear/succinct code that doesn't recompute things unnecessarily.\n\n\n\n","category":"macro"},{"location":"api/#CMBLensing.@sym_memo-Tuple{Any}","page":"API","title":"CMBLensing.@sym_memo","text":"# symmetric in any of its final arguments except for bar:\n@sym_memo foo(bar, @sym(args...)) = <body> \n# symmetric in (i,j), but not baz\n@sym_memo foo(baz, @sym(i, j)) = <body>\n\nThe @sym_memo macro should be applied to a definition of a function which is symmetric in some of its arguments. The arguments in which its symmetric are specified by being wrapping them in @sym, and they must come at the very end. The resulting function will be memoized and permutations of the arguments which are equal due to symmetry will only be computed once.\n\n\n\n\n\n","category":"macro"},{"location":"api/#CMBLensing.FFTW_NUM_THREADS","page":"API","title":"CMBLensing.FFTW_NUM_THREADS","text":"The number of FFTW threads to use. This must be set via e.g.:\n\nCMBLensing.FFTW_NUM_THREADS[] = 4\n\nbefore creating any FlatField objects; subsequent changes to this variable will be ignored. The default value is the environment variable FFTW_NUM_THREADS, or if that is not specified its Sys.CPU_THREADS÷2.\n\n\n\n\n\n","category":"constant"},{"location":"02_posterior/#The-Lensing-Posterior-1","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"","category":"section"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"At its heart, CMBLensing.jl is centered around the \"CMB lensing posterior\". We work with both the \"joint posterior\", which is joint over all variables,","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":" mathcalP(fphithetad) ","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"or the \"marginal posterior\", ","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":" mathcalP(phithetad) equiv int  mathcalDf  mathcalP(fphithetad) ","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"which is simply the joint posterior analytically marginalized over f. Here,","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"f are the CMB fields (T/Q/U),\nphi is the lensing potential,\ntheta are any cosmological parameters,\nd is the data.","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"The default data model which is assumed, which is generally flexible enough to handle real experiments (but can be customized), is:","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":" d =  mathbbA  mathbbL(phi)  f + n ","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"where","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":" mathbbA = mathbbP  mathbbM  mathbbB ","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"and ","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"mathbbL(phi) is the lensing operation\nmathbbB is an instrumental transfer function or \"beam\"\nmathbbM is a user-chosen mask\nmathbbP is a pixelization operation which allows one to estimate f on a higher resolution than the data\nn is the instrumental noise. ","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Given this model, the joint posterior (up to an unimportant normalization constant) is:","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":" \n-2lnmathcalP(fphithetad) = fracbig(d - mathbbA  mathbbL(phi)  fbig)^2mathbbC_n\n+ fracf^2mathbbC_f(theta) + fracphi^2C_phi(theta) + logdet mathbbC_f(theta) + logdet C_phi(theta)\n","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"and the marginal posterior is:","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":" \n-2lnmathcalP(phithetad) = fracd^2mathbbSigma_d(phitheta) + fracphi^2C_phi(theta) + logdet mathbbSigma_d(phitheta) + logdet C_phi(theta)\n","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"where","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"\nSigma_d = mathbbA  mathbbL(phi)  mathbbC_f(theta)  mathbbL(phi)^dagger mathbbA^dagger + mathbbC_n\n","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"and","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"mathbbC_n is the noise covariance\nmathbbC_f is the CMB covariance (i.e. the CMB T, E, and B C_ell's)\nmathbbC_phi is the lensing potential covariance (i.e. C_ell^phiphi)","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"and we have used the slighly sloppy notation x^2mathbbC to mean x^dagger mathbbC^-1 x.","category":"page"},{"location":"02_posterior/#Posterior-basics-1","page":"The Lensing Posterior","title":"Posterior basics","text":"","category":"section"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"using CMBLensing, PyPlot","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"CMBLensing uses the function lnP to compute the log of the joint posterior probability. ","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"To evaluate this posterior, we need the arguments of the probability distribution, f, phi, and theta. We also need the data d and host of other operators and covariances which enter the expressions above, which CMBLensing stores in a DataSet object.","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"First lets load up some simulated data. The function load_sim_dataset handles constructing a DataSet and is the recommended way to create the various fields and covariances needed. In this case, let's use 1muK-arcmin noise and a border mask:","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"@unpack f, f̃, ϕ, ds, L = load_sim_dataset(\n    θpix      = 2,\n    Nside     = 256,\n    T         = Float64,\n    pol       = :P,\n    μKarcminT = 1,\n    L         = LenseFlow{RK4Solver{10}},\n    seed      = 0,\n    pixel_mask_kwargs = (edge_padding_deg=1, apodization_deg=0, num_ptsrcs=0),\n    bandpass_mask     = LowPass(5000)\n);","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"The DataSet object, by convention called ds, stores all the aforementioned quantities:","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"fieldnames(typeof(ds))","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"For example, the data is:","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"plot(ds.d);","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Or the diagonal of the mathbbC_f operator:","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"plot(diag(ds.Cf), which=[:El :Bl])","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"We can now evaluate the posterior, for example at the true f and phi:","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"-2*lnP(0, f, ϕ, ds)","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"The first argument, in this case 0, indicates the parameterization. We can compute the posterior given a couple of different parametrizations,","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"The unlensed parametrization, mathcalP(fphithetad)\nThe lensed parametrization, mathcalP(tilde fphithetad) where tilde f are the lensed CMB fields.\nThe mixed parametrization, mathcalP(f^prime phi^prime theta  d) where f^prime and phi^prime are the mixed CMB fields and lensing potential (this is a parametrization which attemps to decorrelate the posterior as much as possible; you may want to read our paper which describes this in more detail).","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"For the unlensed and lensed parametrizations, pass 0 and 1 as the first argument  (these refer to auxillary \"time\" variable in the LenseFlow expansion, f(x+tnablaphi); at t=0 we have the unlensed field, and at t=1 we have the lensed field). If we use the lensed parametrization, then the f argument to the function is expected to be the lensed field. The mixed parametrization can be specified by passing :mix as the first argment, in which case the f argument is expected to be the mixed field.","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"For example, the following is the same point in parameter space that we evaluated above, just in a different parametrization (any differences to the above value are numerical):","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"-2*lnP(1, L(ϕ)*f, ϕ, ds)","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"We expect minus twice the posterior evaluated at the truth to be distributed like a chi^2 distribution where the degrees of freedom equals the number of pixels in d, f, and phi (i.e. in each of the three Gaussian terms in the posterior). Since these maps are 256x256 and d and f have both Q and U maps, this is:","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"(2+2+1)*256^2","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"which the previous result is within a few sigma of.","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Above, we didn't specify any cosmological parameters, theta. Because of that, they were fixed at their fiducial values (i.e. the fiducial values which generated the simulated data in the call to load_sim_dataset earlier). Current only two parameters can be varied, r (tensor-to-scalar ratio), and A_phi (the amplitude of C_ell^phi phi). They can be specified as follows, with non-specified parameters left at their fiducial:","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"-2*lnP(0, f, ϕ, (Aϕ=1.1,), ds)","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"You can see the slight change compared to what we got above. We can even compute a whole slice through the posterior along A_phi:","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Aϕs = range(0.5,1.5,length=50)\nplot(Aϕs, [lnP(0, f, ϕ, (Aϕ=Aϕ,), ds) for Aϕ in Aϕs])\nxlabel(raw\"$A_\\phi$\")\nylabel(raw\"$\\mathcal{P}(f_{\\rm true}, \\phi_{\\rm true}, A_\\phi\\,|\\,d)$\");","category":"page"},{"location":"02_posterior/#Wiener-filtering-1","page":"The Lensing Posterior","title":"Wiener filtering","text":"","category":"section"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"If we fix phi and theta then maximize the joint posterior, mathcalP(fphithetad), over f, we get","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"\nhat f_rm wf = big mathbbC_f(theta)^-1 + mathbbL(phi)^dagger mathbbA^daggermathbbC_n^-1mathbbA  mathbbL(phi) big^-1 mathbbL(phi)^dagger mathbbA^daggermathbbC_n^-1d\n","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"This is simply the Wiener filter of the data given a signal covariance which includes correlations induced by phi, and we can compute it by inverting the operator in brackets above with e.g. conjugate gradient. ","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"In CMBLensing.jl, the argmaxf_lnP function performs this task. Its arguments are similar to lnP,","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"f_wf = argmaxf_lnP(ϕ, (Aϕ=1,), ds, tol=1e-1, progress=true);","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Wiener filtering effectively delenses the data by a given phi. Here we are Wiener filtering at the true phi, so this is perfect delensing. Note below the large amount of B mode power in the data, as well as the aliasing near the border mask, and how this is removed in the Wiener filtered B, which visually is tracing the true B map up to the level of the noise.","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"plot([ds.d, f_wf, f], title=[\"data \", \"Wiener filtered \", \"true \"] .* [\"E\" \"B\"]);","category":"page"},{"location":"02_posterior/#Posterior-gradients-1","page":"The Lensing Posterior","title":"Posterior gradients","text":"","category":"section"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Fundamental to maximization and sampling algorithms in high dimensions are gradients of the posterior. CMBLensing.jl uses the interface provided by the automatic differentiation library Zygote to compute these gradients.","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"using Zygote","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Zygote provides the gradient function, which takes a function for which to evaluate the gradient as the first argument, and the value at which to evaluate the gradient as the second argument. For example:","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"gradient(x->3x^2+2x, 1)","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Gradients of the CMB lensing posterior work in exactly the same way. For example, to take the gradient with respect to phi in the lensed parametrization, where we fix f to the Wiener filter computed above and evaluate the gradient at phi=0, we can do:","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"gϕ = gradient(ϕ -> lnP(1,f_wf,ϕ,ds), 0ϕ)[1];","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Here's what this gradient looks like multiplied by mathbbC_phi. This is actually the first gradient step in the iterative joint maximum a posteriori estimation. The feature you see below is the mean-field in this estimate due to the mask:","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"plot(ds.Cϕ*gϕ)","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"You are free to manipulate the fields inside of the function whose gradient is being taken, and Zygote will automatically propagate the chain rule for you:","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"gradient(ϕ -> -2lnP(1,f_wf,3ϕ,ds), 0ϕ)[1] ≈ -6 * gradient(ϕ -> lnP(1,f_wf,ϕ,ds), 0ϕ)[1]","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Currently Zygote is working with many (but not all) operations that you can do to fields. If you run into things which Zygote is not able to differentiate successfully (generally you'll get some error), please feel free to file an Issue with CMBLensing.jl.","category":"page"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"Automatic differentiation is not yet working with respect to cosmological parameters, theta, but is planned to be added.","category":"page"},{"location":"02_posterior/#Marginal-posterior-1","page":"The Lensing Posterior","title":"Marginal posterior","text":"","category":"section"},{"location":"02_posterior/#","page":"The Lensing Posterior","title":"The Lensing Posterior","text":"work in progress","category":"page"},{"location":"03_joint_MAP_example/#MAP-estimation-1","page":"MAP estimation","title":"MAP estimation","text":"","category":"section"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"Here, we give an example of how to compute the joint maximum a posteriori (MAP) estimate of the CMB temperature and polarization fields, f, and the lensing potential, phi.","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"using CMBLensing, PyPlot","category":"page"},{"location":"03_joint_MAP_example/#Compute-spectra-1","page":"MAP estimation","title":"Compute spectra","text":"","category":"section"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"First, we compute the fiducial CMB power spectra which generate our simulated data,","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"Cℓ = camb(r=0.05);","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"Next, we chose the noise power-spectra:","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"Cℓn = noiseCℓs(μKarcminT=1, ℓknee=100);","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"Plot these up for reference,","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"loglog(Cℓ.total.BB,c=\"C0\")\nloglog(Cℓ.unlensed_total.BB,\"--\",c=\"C0\")\nloglog(Cℓ.total.EE,c=\"C1\")\nloglog(Cℓ.unlensed_total.EE,\"--\",c=\"C1\")\nloglog(Cℓn.BB,\"k:\")\nlegend([\"lensed B\",\"unlensed B\",\"lensed E\",\"unlensed E\", \"noise (beam not deconvolved)\"]);","category":"page"},{"location":"03_joint_MAP_example/#Configure-the-type-of-data-1","page":"MAP estimation","title":"Configure the type of data","text":"","category":"section"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"These describe the setup of the simulated data we are going to work with (and can be changed in this notebook),","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"θpix  = 3        # pixel size in arcmin\nNside = 128      # number of pixels per side in the map\npol   = :P       # type of data to use (can be :T, :P, or :TP)\nT     = Float32  # data type (Float32 is ~2 as fast as Float64);","category":"page"},{"location":"03_joint_MAP_example/#Generate-simulated-data-1","page":"MAP estimation","title":"Generate simulated data","text":"","category":"section"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"With these defined, the following generates the simulated data and returns the true unlensed and lensed CMB fields, f and f̃ ,and the true lensing potential, ϕ, as well as a number of other quantities stored in the \"DataSet\" object ds. ","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"@unpack f, f̃, ϕ, ds = load_sim_dataset(\n    seed = 3,\n    Cℓ = Cℓ,\n    Cℓn = Cℓn,\n    θpix = θpix,\n    T = T,\n    Nside = Nside,\n    pol = pol,\n)\n\n@unpack Cf, Cϕ = ds;","category":"page"},{"location":"03_joint_MAP_example/#Examine-simulated-data-1","page":"MAP estimation","title":"Examine simulated data","text":"","category":"section"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"The true phi map,","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"plot(ϕ, title = raw\"true $\\phi$\");","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"The \"true\" unlensed field, f,","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"plot(f, title = \"true unlensed \" .* [\"E\" \"B\"]);","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"And the \"true\" lensed field,","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"plot(LenseFlow(ϕ)*f, title = \"true lensed \" .* [\"E\" \"B\"]);","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"The data (stored in the ds object) is basically f̃ with a beam applied plus a sample of the noise,","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"plot(ds.d, title = \"data \" .* [\"E\" \"B\"]);","category":"page"},{"location":"03_joint_MAP_example/#Run-the-optimizer-1","page":"MAP estimation","title":"Run the optimizer","text":"","category":"section"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"Now we compute the maximum of the joint posterior, mathcalPbig(f phi bigdbig)","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"@time fbf, ϕbf, tr = MAP_joint(ds, nsteps=30, progress=:verbose, αmax=0.1);","category":"page"},{"location":"03_joint_MAP_example/#Examine-results-1","page":"MAP estimation","title":"Examine results","text":"","category":"section"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"The expected value of the final best-fit chi^2 (=-2log mathcalP) is given by the number degrees of freedom in the data, i.e. the total number of pixels in T and/or EB.","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"χ² = -2tr[end][:lnPcur]","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"dof = length(Map(f)[:])","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"Here's how far away our final chi^2 is from this expectation, in units of sigma. We expect this should be somewhere in the range (-3,3) for about 99.7% of simulated datasets.","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"(χ² - dof)/sqrt(2dof)","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"Here's the best-fit phi relative to the truth,","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"plot(10^6*[ϕ ϕbf], title=[\"true\" \"best-fit\"] .* raw\" $\\phi$\", vlim=17);","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"Here is the difference in terms of the power spectra. Note the best-fit has high-ell power suppressed, like a Wiener filter solution (in fact what we're doing here is akin to a non-linear Wiener filter). In the high S/N region (elllesssim1000), the difference is approixmately equal to the noise, which you can see is almost two orders of magnitude below the signal.","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"ℓedges = 100:200:3000","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"semilogx(get_ρℓ(ϕbf,ϕ))","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"(1 / get_ρℓ(ϕbf,ϕ)^2 - 1)","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"chain = sample_joint(\n    ds,\n    symp_kwargs = [(N=25, ϵ=0.05)],\n    nsamps_per_chain = 100,\n    nchains = 1, \n    nburnin_always_accept = Inf,\n    progress = :summary\n);","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"get_ρℓ(ϕ,ϕbf,ℓedges=100:50:3000)","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"plot(ϕbf, which=:Il)","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"loglog(ℓ⁴*Cℓ.total.ϕϕ)\nloglog(ℓ⁴*Cℓ.total.ϕϕ * (1 / get_ρℓ(ϕbf,ϕ,Δℓ=25)^2 - 1))","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"loglog(ℓ⁴ * Cℓ.total.ϕϕ, \"k\")\nloglog(get_ℓ⁴Cℓ(ϕ))\nloglog(get_ℓ⁴Cℓ(ϕbf))\nloglog(get_ℓ⁴Cℓ(ϕbf-ϕ))\nxlim(80,3000)\nylim(5e-9,2e-6)\nlegend([\"theory\",raw\"true $\\phi$\", raw\"best-fit $\\phi$\", \"difference\"])\nxlabel(raw\"$\\ell$\")\nylabel(raw\"$\\ell^4 C_\\ell$\");","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"The best-fit unlensed fields relative to truth,","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"plot([f,fbf], title = [\"true\", \"best-fit\"] .* \" unlensed \" .* [\"E\" \"B\"]);","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"The best-fit lensed field (bottom row) relative to truth (top row),","category":"page"},{"location":"03_joint_MAP_example/#","page":"MAP estimation","title":"MAP estimation","text":"plot([f̃, LenseFlow(ϕbf)*fbf], title = [\"true\", \"best-fit\"] .* \" lensed \" .* [\"E\" \"B\"]);","category":"page"},{"location":"04_from_python/#Calling-from-Python-1","page":"Calling from Python","title":"Calling from Python","text":"","category":"section"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"Calling Julia and CMBLensing.jl directly from Python is very transparent. This is made possible by the PyJulia package. You can install it into your Python environment with, e.g.:","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"$ pip install --user julia","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"Important: If your Python executable is statically-linked (this is quite often the case, e.g. its the default on Ubuntu and Conda) you need one extra step. Basically, instead of running python or ipython at the command line to launch your interpreter, run python-jl  or python-jl -m IPython, respectively. If you use Jupyter, you'll need to edit your kernel.json file (you can find its location via jupyter kernelspec list) and change it to use python-jl.","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"The wrapper script python-jl does some special initializion but otherwise drops you into the Python/IPython interpreter that you are familiar with. ","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"The PyJulia docs also give instructions on how to install a dynamically-linked Python executable which is the most ideal solution, and only slightly more work than above.","category":"page"},{"location":"04_from_python/#Basics-of-calling-Julia-1","page":"Calling from Python","title":"Basics of calling Julia","text":"","category":"section"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"Once PyJulia is installed, you can access any Julia package Foo from the Python package julia.Foo, and everything pretty much works the same.","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"import julia.Base","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"julia.Base.cos(1) # <--- this is Julia's cosine function","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"You can also run arbitrary Julia code with the %julia cell magic (this is helpful if you want to use Julia language features or syntax which don't exist in Python):","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"%load_ext julia.magic","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"For example, 1:10 is not valid Python syntax, but we can do:","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"%julia 1:10","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"The cell magic lets you interpolate values from Python into the Julia expression, which can be a convenient way to pass values back and forth:","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"x = %julia 1 + 2","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"%julia 2 * $x","category":"page"},{"location":"04_from_python/#Calling-CMBLensing.jl-1","page":"Calling from Python","title":"Calling CMBLensing.jl","text":"","category":"section"},{"location":"04_from_python/#Via-magic-1","page":"Calling from Python","title":"Via magic","text":"","category":"section"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"The most robust way to call CMBLensing.jl from Python is just to wrap everything in Julia magic and interpolate things back and forth as-needed. Lets try and follow the Lensing a flat-sky map example from Python. First, we load the package:","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"%%julia\nusing CMBLensing","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"Next, we simulate some data:","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"%%julia\n@unpack f,ϕ = load_sim_dataset(\n    θpix  = 2,\n    Nside = 256,\n    T     = Float32,\n    pol   = :I\n);","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"Similarly, the rest of the commands from that example will work in Python if just called via Julia magic.","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"At any point, you can do whatever you'd like with any of the results stored in Julia variables, e.g. transferring the simulated maps back as Python arrays,","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"f = %julia f[:Ix]\nf","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"You can also pass variables back to Julia, e.g.","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"%julia g = FlatMap($f);","category":"page"},{"location":"04_from_python/#Directly-1","page":"Calling from Python","title":"Directly","text":"","category":"section"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"You can also call Julia directly without magic, which sometimes offers more flexibility, although has some limitations. ","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"To do so, first import CMBLensing. into Python. In Julia, using CMBLensing imports all of the CMBLensing symbols into the current namespace. In Python this is:","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"from julia.CMBLensing import *","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"If we want to call load_sim_dataset as before, we must take into account a few things:","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"You won't be able to use the @unpack macro since macros on arbitrary code don't exist in Python.\nFloat32 isn't imported into Python by default, so you'll need to specify the module. \nThe :P is invalid syntax in Python, you should use a string \"P\" instead. ","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"Given all of that, the call will look like:","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"sim = load_sim_dataset(\n    θpix  = 2, \n    Nside = 256, \n    T     = julia.Base.Float32, \n    pol   = \"P\"\n)","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"If we wish to grab the lensing potential from the result, there's an additional consideration. Python does not differentiate between the characters ϕ (\\phi) and φ (\\varphi), and maps both of them back to φ (\\varphi) in Julia, which unfortunately is the wrong one for CMBLensing (which instead makes extensive use of the variable name ϕ (\\phi)). Thus, calling sim.ϕ from Python does not work. Instead, we have to do that part in Julia:","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"ϕ = %julia $sim.ϕ","category":"page"},{"location":"04_from_python/#Plotting-1","page":"Calling from Python","title":"Plotting","text":"","category":"section"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"To plot, we need to use the plot function from Julia's PyPlot, since this will know about plotting CMBLensing objects. ","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"from julia.PyPlot import plot","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"%matplotlib inline","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"plot(ϕ);","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"For non-CMBLensing objects, this plot function will just pass-through to matplotlib, so will not affect affect your session otherwise.","category":"page"},{"location":"04_from_python/#","page":"Calling from Python","title":"Calling from Python","text":"plot([1,2,3]);","category":"page"},{"location":"05_field_basics/#Field-Basics-1","page":"Field Basics","title":"Field Basics","text":"","category":"section"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"using CMBLensing","category":"page"},{"location":"05_field_basics/#Base-Fields-1","page":"Field Basics","title":"Base Fields","text":"","category":"section"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"The basic building blocks of CMBLensing.jl are CMB \"fields\", like temperature, Q or U polarization, or the lensing potential phi. These types are all encompassed by the abstract type Field, with some concrete examples including FlatMap for a flat-sky map projection, or FlatQUMap for Q/U polarization, etc...","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Flat fields are just thin wrappers around Julia arrays, e.g.","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Ix = rand(2,2)","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"2×2 Array{Float64,2}:\n 0.31216   0.3233\n 0.951855  0.412498","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f = FlatMap(Ix)","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:\n 0.31215964516658445\n 0.951855395392009\n 0.3232999743978888\n 0.41249780366626454","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"When displayed, you can see the pixels in the 2x2 map have been splayed out into a length-4 array. This is intentional, as even though the maps themselves are two-dimensional, it is extremely useful conceptually to think of fields as vectors (which they are, in fact, as they form an abstract vector space). This tie to vector spaces is deeply rooted in CMBLensing, to the extent that Field objects are a subtype of Julia's own AbstractVector type, ","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f isa AbstractVector","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"true","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"The data itself, however, is still stored as the original 2x2 matrix, and can be accessed as follows,","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f.Ix","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"2×2 Array{Float64,2}:\n 0.31216   0.3233\n 0.951855  0.412498","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"But since Fields are vectors, they can be tranposed,","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f'","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"1×4 LinearAlgebra.Adjoint{Float64,FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}}:\n 0.31216  0.951855  0.3233  0.412498","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"inner products can be computed,","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f' * f","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"1.2781496492825735","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"and they can be added with each other as well as multiplied by scalars,","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"2*f+f","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:\n 0.9364789354997534\n 2.855566186176027\n 0.9698999231936665\n 1.2374934109987936","category":"page"},{"location":"05_field_basics/#Diagonal-operators-1","page":"Field Basics","title":"Diagonal operators","text":"","category":"section"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Vector spaces have linear operators which act on the vectors. Linear operators correpsond to matrices, thus for a map with N total pixels, a general linear operator would be an N-by-N matrix, which for even modest map sizes becomes far too large to actually store. Thus, an important class of linear operators are ones which are diagonal, since these can actually be stored. CMBLensing uses Julia's builtin Diagonal to represent these. Diagonal(f) takes a vector f and puts it on the diagonal of the matrix:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Diagonal(f)","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4×4 Diagonal{Float64,FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}}:\n 0.31216   ⋅         ⋅       ⋅ \n  ⋅       0.951855   ⋅       ⋅ \n  ⋅        ⋅        0.3233   ⋅ \n  ⋅        ⋅         ⋅      0.412498","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Multiplying this operator by the original map is then a matrix-vector product:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Diagonal(f) * f","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:\n 0.09744364407052791\n 0.9060286937368779\n 0.10452287344567557\n 0.17015443802949212","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Note that this is also equal to the the pointwise multiplication of f with itself:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f .* f","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:\n 0.09744364407052791\n 0.9060286937368779\n 0.10452287344567557\n 0.17015443802949212","category":"page"},{"location":"05_field_basics/#Field-Tuples-1","page":"Field Basics","title":"Field Tuples","text":"","category":"section"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"You can put Fields together into tuples. For example, ","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"a = FlatMap(rand(2,2))\nb = FlatMap(rand(2,2));","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"FieldTuple(a,b)","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"8-element Field2Tuple{CMBLensing.BasisTuple{Tuple{Map,Map}}, Float64}:\n 0.5605310842551368\n 0.10490717028322405\n 0.5828183846569281\n 0.8044950716933108\n 0.267355451626792\n 0.9909841666578676\n 0.6557362522005716\n 0.31704558307644093","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"The components can also have names:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"ft = FieldTuple(a=a, b=b)","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"8-element Field2Tuple{(:a, :b), CMBLensing.BasisTuple{Tuple{Map,Map}}, Float64}:\n 0.5605310842551368\n 0.10490717028322405\n 0.5828183846569281\n 0.8044950716933108\n 0.267355451626792\n 0.9909841666578676\n 0.6557362522005716\n 0.31704558307644093","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"which can be accessed later:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"ft.a","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:\n 0.5605310842551368\n 0.10490717028322405\n 0.5828183846569281\n 0.8044950716933108","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"FieldTuples have all of the same behavior of individual fields. Indeed, spin fields like QU or IQU are simply special FieldTuples:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"fqu = FlatQUMap(a,b)\nfqu isa FieldTuple","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"true","category":"page"},{"location":"05_field_basics/#Field-Vectors-1","page":"Field Basics","title":"Field Vectors","text":"","category":"section"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"in progress","category":"page"},{"location":"05_field_basics/#Basis-Conversion-1","page":"Field Basics","title":"Basis Conversion","text":"","category":"section"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"All fields are tagged as to which basis they are stored in. You can convert them to other bases by calling the basis type on them:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:\n 0.31215964516658445\n 0.951855395392009\n 0.3232999743978888\n 0.41249780366626454","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f′ = Fourier(f)","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4-element FlatFourier{2×2 map, 1′ pixels, fourier∂, Array{Complex{Float64}}}:\n  1.9998128186227468 + 0.0im\n -0.7288935794938003 + 0.0im\n  0.5282172624944401 + 0.0im\n -0.5504979209570489 + 0.0im","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Basis conversion is usually done automatically for you. E.g. here f′ is automatically converted to a FlatMap before addition:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f + f′","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:\n 0.6243192903331689\n 1.903710790784018\n 0.6465999487957776\n 0.8249956073325291","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"A key feature of Diagonal operators is they convert the field they are acting on to the right basis before multiplication:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Diagonal(f) * f′","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:\n 0.09744364407052791\n 0.9060286937368779\n 0.10452287344567557\n 0.17015443802949212","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"A FlatMap times a FlatFourier doesn't have a natural linear algebra meaning so its an error:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f * f′","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"MethodError: no method matching *(::FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}, ::FlatFourier{2×2 map, 1′ pixels, fourier∂, Array{Complex{Float64}}})\nClosest candidates are:\n  *(::Any, ::Any, !Matched::Any, !Matched::Any...) at operators.jl:529\n  *(!Matched::FuncOp, ::Field) at /home/cosmo/CMBLensing/src/specialops.jl:118\n  *(!Matched::LinearAlgebra.Adjoint{#s662,#s661} where #s661<:LinearAlgebra.AbstractTriangular where #s662, ::AbstractArray{T,1} where T) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.4/LinearAlgebra/src/triangular.jl:1971\n  ...\n\n\n\nStacktrace:\n\n [1] top-level scope at In[21]:1","category":"page"},{"location":"05_field_basics/#Properties-and-indices-1","page":"Field Basics","title":"Properties and indices","text":"","category":"section"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"FlatMap and FlatFourier can be indexed directly like arrays. If given 1D indices, this is the index into the vector representation:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:\n 0.31215964516658445\n 0.951855395392009\n 0.3232999743978888\n 0.41249780366626454","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f[1], f[2], f[3], f[4]","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"(0.31215964516658445, 0.951855395392009, 0.3232999743978888, 0.41249780366626454)","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f[5]","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"BoundsError: attempt to access 2×2 Array{Float64,2} at index [5]\n\n\n\nStacktrace:\n\n [1] getindex at ./array.jl:787 [inlined]\n\n [2] getindex(::FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}, ::Int64) at /home/cosmo/CMBLensing/src/flat_s0.jl:43\n\n [3] top-level scope at In[24]:1","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Or with a 2D index, this indexes directly into the 2D map:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f[1,1], f[2,1], f[1,2], f[2,2]","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"(0.31215964516658445, 0.951855395392009, 0.3232999743978888, 0.41249780366626454)","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Note: there is no overhead to indexing f in this way as compared to working directly on the underlying array.","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"For other fields which are built on FieldTuples, 1D indexing will instead index the tuple indices:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"ft","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"8-element Field2Tuple{(:a, :b), CMBLensing.BasisTuple{Tuple{Map,Map}}, Float64}:\n 0.5605310842551368\n 0.10490717028322405\n 0.5828183846569281\n 0.8044950716933108\n 0.267355451626792\n 0.9909841666578676\n 0.6557362522005716\n 0.31704558307644093","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"ft[1]","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:\n 0.5605310842551368\n 0.10490717028322405\n 0.5828183846569281\n 0.8044950716933108","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"ft[2]","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:\n 0.267355451626792\n 0.9909841666578676\n 0.6557362522005716\n 0.31704558307644093","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"ft[3]","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"BoundsError: attempt to access NamedTuple{(:a, :b),Tuple{FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}},FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}}}\n  at index [3]\n\n\n\nStacktrace:\n\n [1] getindex at ./namedtuple.jl:94 [inlined]\n\n [2] getindex(::Field2Tuple{(:a, :b), CMBLensing.BasisTuple{Tuple{Map,Map}}, Float64}, ::Int64) at /home/cosmo/CMBLensing/src/field_tuples.jl:47\n\n [3] top-level scope at In[29]:1","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"To get the underlying data arrays, use the object's properties:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f.Ix","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"2×2 Array{Float64,2}:\n 0.31216   0.3233\n 0.951855  0.412498","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"You can always find out what properties are available by typing f.<Tab>. For example, if you typed ft then hit <Tab> you'd get:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"ft |> propertynames","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"(:fs, :a, :b)","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"For a FieldTuple like the FlatQUMap object, fqu, you can get each individual Q or U field:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"fqu.Q","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"4-element FlatMap{2×2 map, 1′ pixels, fourier∂, Array{Float64}}:\n 0.5605310842551368\n 0.10490717028322405\n 0.5828183846569281\n 0.8044950716933108","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Or fqu.Qx which is shorthand for fqu.Q.Ix:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"fqu.Q.Ix === fqu.Qx","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"true","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"If you convert f to Fourier space, it would have the Il property to get the Fourier coefficients of the I component:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Fourier(f).Il","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"2×2 Array{Complex{Float64},2}:\n   1.99981+0.0im   0.528217+0.0im\n -0.728894+0.0im  -0.550498+0.0im","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"For convenience, you can index fields with brackets [] and any necessary conversions will be done automatically:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"f[:Il]","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"2×2 Array{Complex{Float64},2}:\n   1.99981+0.0im   0.528217+0.0im\n -0.728894+0.0im  -0.550498+0.0im","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"This works between any bases. For example. fqu is originally QUMap but we can convert to EBFourier and get the El coefficients:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"fqu[:El]","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"2×2 Array{Complex{Float64},2}:\n -2.05275-0.0im  0.721875+0.0im\n 0.233947+0.0im   1.06232+0.0im","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"The general rule to keep in mind for these two ways of accessing the underlying data is:","category":"page"},{"location":"05_field_basics/#","page":"Field Basics","title":"Field Basics","text":"Properties (i.e. f.Ix) are type-stable and get you the underlying data arrays, even recursively from special FieldTuples like FlatQUMap, etc... If these arrays are modified, they affect the original field.\nIndices (i.e. f[:Ix]) are not type-stable, and may or may not be one of the underlying data arrays (because a basis conversion may have been performed). They should be used for getting (not setting) data, and in non-performance-critical code. ","category":"page"},{"location":"#CMBLensing.jl-1","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"","category":"section"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"(Image: ) (Image: ) (Image: Binder) (Image: Build Status)","category":"page"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"CMBLensing.jl is a next-generation tool for analysis of the lensed Cosmic Microwave Background. It is written in Julia and transparently callable from Python.","category":"page"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"At its heart, CMBLensing.jl maximizes or samples the Bayesian posterior for the CMB lensing problem. It also contains tools to quickly manipulate and process CMB maps, set up modified posteriors, and take gradients using automatic differentation.","category":"page"},{"location":"#Highlights-1","page":"CMBLensing.jl","title":"Highlights","text":"","category":"section"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"Fully Nvidia GPU compatible (speedups over CPU are currently 3x-10x, depending on the problem size and hardware).\nAutomatic differentation (via Zygote.jl) provides for-free gradients of your custom posteriors.\nIncludes the following algorithms to lense a map:\nLenseFlow (Millea, Anderes, & Wandelt 2017)\nTaylens (Næss & Louis 2013)\nTaylor series expansion to any order\nBilinear interpolation\nMaximize and sample mathcalP(fphithetad), the joint maximum a posteriori estimate of the lensing potential, phi, the  temperature and/or polarization fields, f, and cosmological parameters, theta (Millea, Anderes, & Wandelt 2017, Millea, Anderes, & Wandelt 2020)\nMaximize mathcalP(phidtheta), i.e. the marginal maximum a posteriori estimate of the lensing potential, phi, at fixed cosmological parameters, theta (Carron & Lewis 2017)\nDo basic quadratic estimation of phi (Hu & Okamoto 2003)","category":"page"},{"location":"#Documentation-1","page":"CMBLensing.jl","title":"Documentation","text":"","category":"section"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"The best place to get started is to read the documentation (which is a work-in-progress, but contains many useful examples). ","category":"page"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"Most of the pages in the documentation are Jupyter notebooks, and you can click the \"launch binder\" link at the top of each page to launch a Jupyterlab server running the notebook in your browser (courtesy of binder). ","category":"page"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"You can also clone the repostiory and open the notebooks in docs/src if you want to run them locally (which will usually lead to higher performance). The notebooks are stored as .md files rather than .ipynb format. Its recommented to install Jupytext (pip install jupytext) and then you can run these .md directly from Jupyterlab by right-clicking on them and selecting Open With -> Notebook. Otherwise, run the script docs/make_notebooks.sh to convert the .md files to .ipynb which you can then open as desired. ","category":"page"},{"location":"#Installation-1","page":"CMBLensing.jl","title":"Installation","text":"","category":"section"},{"location":"#Requirements-1","page":"CMBLensing.jl","title":"Requirements","text":"","category":"section"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"Julia 1.3 or higher\n(optional) Python 3 + matplotlib (used for plotting)\n(optional) pycamb to generate C_ell's\n(optional) An Nvidia GPU and CuArrays for GPU support\n(optional) healpy for experimental curved sky support","category":"page"},{"location":"#Native-installation-1","page":"CMBLensing.jl","title":"Native installation","text":"","category":"section"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"To install the Julia package locally, run:","category":"page"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"pkg> add CMBLensing","category":"page"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"(type ] at the Julia REPL to reach the pkg> prompt)","category":"page"},{"location":"#Docker-installation-1","page":"CMBLensing.jl","title":"Docker installation","text":"","category":"section"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"Also provided is a Docker container which includes a Jupyterlab server and all the recommended and optional dependencies to run and use CMBLensing.jl. Launch this container with:","category":"page"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"git clone https://github.com/marius311/CMBLensing.jl.git\ncd CMBLensing.jl\ndocker-compose pull\ndocker-compose up","category":"page"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"The first time you run this, it will automatically download the (~1Gb) container from the Docker hub. The command will prompt you with the URL which you should open in a browser to access the notebook.","category":"page"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"To run the notebook on a different port than the default 8888, do PORT=1234 docker-compose up where 1234 is whatever port number you want.","category":"page"},{"location":"#","page":"CMBLensing.jl","title":"CMBLensing.jl","text":"You can also build the container locally by replacing docker-compose pull with docker-compose build above.","category":"page"}]
}
